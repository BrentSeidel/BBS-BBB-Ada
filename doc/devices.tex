\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage{tikz}
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
%  Setup indexes
%
\makeindex[name=type,title=List of Datatypes,columns=3]
\newcommand{\indextype}[1]{\index[type]{#1}}
\makeindex[name=func,title=List of Functions/Procedures,columns=3]
\newcommand{\indexfunc}[1]{\index[func]{#1}}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\cli}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
\newcommand{\comment}[1]{{\color{red}{#1}}}
%
\newcommand{\docname}{Users's Manual for \\ Device Interfaces}
%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024, Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\listoftables

\mainmatter
%========================================================
\chapter{Introduction}

%--------------------------------------------------------------------------------------------------
\section{About the Project}
This project provides an interface to hardware available on some Linux based systems and the Arduino Due.  It consists of two main components:  First an abstract set of classes for certain generic hardware items, and second specific classes to interface with the hardware on specific devices.  This separation is done to ease porting of software between different devices.  The two Linux based devices that are currently supported are the Raspberry Pi and the BeagleBone Black.  Other devices may be added by creating a set of specific classes for the device.

%--------------------------------------------------------------------------------------------------
\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How to Obtain}

This collection is currently available on GitHub at \url{https://github.com/BrentSeidel/BBS-BBB-Ada}.  Parts are available through alire via ``\keyword{alr get bbs\_embed\_common}'' and ``\keyword{alr get bbs\_embed\_linux}''

%--------------------------------------------------------------------------------------------------
\section{Dependencies}
\subsection{bbs\_embed\_common}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Integer\_Text\_IO}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions} (used only by lsm303dlhc)
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Text\_IO}
  \item \package{Ada.Unchecked\_Conversion}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed.GPIO}
  \item \package{BBS.embed.i2c}
  \item \package{BBS.embed.log}
  \item \package{BBS.embed.SPI}
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_linux}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Direct\_IO}
  \item \package{Ada.IO\_Exceptions}
  \item \package{Ada.Long\_Integer\_Text\_IO}
  \item \package{Ada.Strings.Fixed}
  \item \package{Ada.Text\_IO}
  \item \package{Interfaces.C}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed}*
  \item \package{BBS.embed.BBB}*
  \item \package{BBS.embed.GPIO}*
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_due}
The Arduino Due requires an appropriate run-time system and cross-compiler.
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Interrupts}
  \item \package{Ada.Interrupts.Names}
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Synchronous\_Task\_Control}
  \item \package{Interfaces}
  \item \package{System}
  \item \package{System.Sam3x8}
\end{itemize}
\subsubsection{SAM3x8e Stuff}
The following SAM3x8e hardware definition packages are used:
\begin{itemize}
  \item \package{SAM3x8e}
  \item \package{SAM3x8e.ADC}
  \item \package{SAM3x8e.PIO}
  \item \package{SAM3x8e.PMC}
  \item \package{SAM3x8e.TWI}
  \item \package{SAM3x8e.UART}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS}*
  \item \package{BBS.embed}*
  \item \package{BBS.embed.due.dev}
  \item \package{BBS.embed.due.serial.int}
  \item \package{BBS.embed.due.serial.polled}
  \item \package{BBS.embed.GPIO.Due}
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
\end{itemize}


%========================================================
\chapter{Usage Instructions}
This chapter contains high-level instructions on using this library in your project.  First, all projects will need to include the \package{bbs\_embed\_common} packages to gain access to the base classes and some device drivers that build on these base classes.  The second step is platform specific, as described below.

%--------------------------------------------------------------------------------------------------
\section{Linux Based Raspberry Pi and BeagleBone Black}
You will need to include the \package{bbs\_embed\_linux} packages in your project.  The \package{BBS.embed.rpi} package contains constants for various device names available on the Raspberry Pi.  The \package{BBS.embed.BBB} package contains constants for various devices names on the BeagleBone Black.  There is a script, \package{init-bbb.sh} for the BeagleBone Black or \package{init-rpi.sh} for the Raspberry Pi that needs to be run to activate some of the devices and set protections on the device files.  The script will need to be run as superuser, using the \cli{sudo} command.  Among other things, it sets protection on the device files so that your software does not need to run as superuser.

%--------------------------------------------------------------------------------------------------
\section{Arduino Due}
This has not been worked on for a while.  To use this, you will need an ARM ELF Ada compiler and a board support package for the Arduino Due.  It did work with a board support package that I'd cobbled together a few generations of gnat ago.  Consider this to be experimental, but it should provide a good start to accessing hardware on the Arduino Due.

%========================================================
\chapter{Common API Description}
Dealing with hardware can be complex, especially if you want your software to be portable.  The various different boards have different devices (or different numbers of devices) available.  Sometimes options are available on one board that are not available on another.

The common library (\package{bbs\_embed\_common} in alire) contains base classes for hardware devices and higher-level drivers for devices that attach to the basic hardware, for example devices that connect via an I2C bus.

%--------------------------------------------------------------------------------------------------
\section{Basic Devices}
The package \package{BBS.embed} defines the following types and functions:
\begin{lstlisting}
type addr7 is mod 2**7
  with size => 7;
type int12 is range -(2**11) .. 2**11 - 1
  with size => 12;
type uint12 is mod 2**12
  with size => 12;
\end{lstlisting}
\indextype{addr7}
\indextype{int12}
\indextype{uint12}
The \datatype{addr7} is used for addressing devices on an I2C bus.  the \datatype{int12} and \datatype{uint12} are used for the return values from typical analog to digital converters and anywhere else a 12 bit number is needed.

\begin{lstlisting}
function uint12_to_int12 is
new Ada.Unchecked_Conversion(source => uint12, target => int12);
\end{lstlisting}
\indexfunc{uint12\_to\_int12}
This is used to convert from unsigned to signed 12 bit integers.  Should the reverse conversion be needed, it would be easy enough to add it here.

\begin{lstlisting}
function highByte(x : uint16) return uint8 is
     (uint8(x / 2**8));
function lowByte(x : uint16) return uint8 is
      (uint8(x and 16#FF#));
\end{lstlisting}
\indexfunc{highByte}
\indexfunc{lowByte}
These are used to extract the MSB and LST from \datatype{uint16} values.

\subsection{\package{BBS.embed.AIN}}
Analog inputs have one common routine to read the value.  Everything else is implementation dependent.
\begin{lstlisting}
function get(self : AIN_record) return uint12 is abstract;
\end{lstlisting}
\indexfunc{get}
Read the value of the specified analog to digital converter.
\begin{itemize}
  \item $self$ - The object for the analog input device.
  \item Returns the 12-bit value from the analog to digital converter.
\end{itemize}

\subsection{\package{BBS.embed.GPIO}}
A GPIO is a device capable of reading or writing a single bit.  The physical characteristics are hardware dependent.  Some device specific routines may be needed to convert between input and output.

\begin{lstlisting}
procedure set(self : GPIO_record; value : bit) is abstract;
\end{lstlisting}
\indexfunc{set}
Sets the output value of a GPIO device.  The effect if the device is set to input is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item $value$ - The value to write to the GPIO device.
\end{itemize}

\begin{lstlisting}
function get(self : GPIO_record) return bit is abstract;
\indexfunc{get}
\end{lstlisting}
Reads the value of a GPIO device.  The value returned if the device is set to output is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item Returns the value read from the GPIO device.
\end{itemize}

\subsection{\package{BBS.embed.i2c}}
An I2C bus can interface with a number of devices on the bus.  It operates with the CPU being the master and the addressed device responding.  The basic I2C bus uses 7 bit addressing for devices and operates at 100kHz.  Any other options (10 bit addressing or higher speeds would be device specific, if supported).

The \package{BBS.embed.i2c} defines some datatypes.  The ones for external use are:
\begin{itemize}
  \item \datatype{err\_code} is an enumeration of error statuses that can be returned.  The possible values are \datatype{none}, \datatype{nack}, \datatype{ovre}, \datatype{invalid\_addr}, and \datatype{failed}.  In most cases you'll just want to compare the returned error to \datatype{none}.
  \item \datatype{buff\_index} is an \datatype{Integer} index into a buffer with a range of 0 .. 127.
  \item \datatype{buffer} is an array of \datatype{uint8} and bounds of \datatype{buff\_index}.  It is used for buffering data for I2C bus transfers.
\end{itemize}
\indextype{err\_code}
\indextype{buff\_index}
\indextype{buffer}

The following routines are used for communicating with devices on the I2C bus.  Note that there is no standard about whether multibyte data should be transferred LSB first or MSB first (I've even seen devices that use both depending on which data you're getting).  Routines are provided for MSB first (m1 routines) or MSB second (m2 routines) for 16 bit transfers.  For longer transfers, use the block transfer routines and decode the data yourself.  The 8 and 16 bit routines cover most of the cases.
\begin{lstlisting}
function read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
              error : out err_code) return uint8 is (0);
\end{lstlisting}
\indexfunc{read}
Read a single byte of data from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
\indexfunc{readm1}
Read two bytes of data with MSB transferred first from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
\indexfunc{readm2}
Read two bytes of data with MSB transferred second from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
procedure read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
               size : buff_index; error : out err_code) is null;
\end{lstlisting}
\indexfunc{read}
Reads a block of data into the interface record's buffer.  The user's code will need to extract the data from that buffer and process it as needed.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                data : uint8; error : out err_code) is null;
\end{lstlisting}
\indexfunc{write}
Write a single byte of data to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
\indexfunc{writem1}
Writes two bytes of data with the MSB transferred first to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
\indexfunc{writem2}
Writes two bytes of data with the MSB transferred second to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                size : buff_index; error : out err_code) is null;
\end{lstlisting}
\indexfunc{write}
Send the specified number of bytes in the interface record's buffer to the specified device and register.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}
In most cases these routines should only be used when writing a driver for an I2C device.

\subsection{\package{BBS.embed.log}}
This package provides the definitions for logging capabilities.  Since not all embedded systems have access to \package{Ada.Text\_IO}, this package is provided.  It defines a logging object that can be subclassed to perform logging on the specific target without having to modify the client packages.  This basic class will simply discard any text.  Note that multiple logging streams may be defined.

The following are the interface to logging:
\begin{lstlisting}
procedure enable(self : in out log_record);
\end{lstlisting}
\indexfunc{enable}
Enables logging on a log stream.
\begin{itemize}
  \item $self$ - The log stream to enable.
\end{itemize}

\begin{lstlisting}
procedure disable(self : in out log_record)
\end{lstlisting}
\indexfunc{disable}
Disables logging on a log stream.
\begin{itemize}
  \item $self$ - The log stream to disable.
\end{itemize}

\begin{lstlisting}
procedure put(self : log_record; text : String);
\end{lstlisting}
\indexfunc{put}
Writes text to a log stream without adding a newline at the end.
\begin{itemize}
  \item $self$ - The log stream to add text to.
  \item $text$ - The text to add.
\end{itemize}

\begin{lstlisting}
procedure put_line(self : log_record; text : String) is null;
\end{lstlisting}
\indexfunc{put\_line}
Writes text to a log stream with a newline at the end.
\begin{itemize}
  \item $self$ - The log stream to add text to.
  \item $text$ - The text to add.
\end{itemize}

The following log streams are defined and can be used for various purposes.  These streams may be used by some of the software in this project for debugging purposes.  They are initialized to the dummy log stream which simply discards any text logged.  Should you wish to use them, you would need to create your own logging class based on \package{log\_record} that actually does something with the text and set the appropriate stream(s) to point to your new subclass.
\begin{lstlisting}
   debug : log_ptr := dummy_log'Access;
   info  : log_ptr := dummy_log'Access;
   error : log_ptr := dummy_log'Access;
\end{lstlisting}

\subsection{\package{BBS.embed.SPI}}
The exposed interface for the SPI bus is much simpler than for the I2C bus.  If needed, more routines may be added here, but this hasn't been developed as much as the I2C bus interface.
\begin{lstlisting}
procedure set(self : SPI_record; value : uint8) is abstract;
\end{lstlisting}
\indexfunc{set}
Writes a byte to the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item $data$ - The data to write.
\end{itemize}
\begin{lstlisting}
function get(self : SPI_record) return uint8 is abstract;
\end{lstlisting}
\indexfunc{get}
Reads a byte from the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item Returns the byte read from the bus.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{Higher-Level Device Drivers}
These higher-level device drivers build on the lower-level devices.  Typically these are devices that attach to a databus.

\subsection{\package{BBS.embed.gpio.tb6612}}
This is a driver for the Toshiba TB6612 dual DC motor controller \cite{TB6612}.  The device driver is designed to sequence the output to drive a stepper motor, or it can control two DC motors separately.  It requires four GPIO output pins.

\begin{lstlisting}
procedure init(self : in out TB6612_record; pin_a : BBS.embed.GPIO.GPIO;
               pin_b : BBS.embed.GPIO.GPIO; pin_c : BBS.embed.GPIO.GPIO;
               pin_d : BBS.embed.GPIO.GPIO);
\end{lstlisting}
\indexfunc{init}
Initialize the TB6612 driver with the 4 GPIO devices.
\begin{itemize}
  \item $self$ - The TB6612 device to initialize.
  \item $pin\_a$ - The first GPIO pin.
  \item $pin\_b$ - The second GPIO pin.
  \item $pin\_c$ - The third GPIO pin.
  \item $pin\_d$ - The fourth GPIO pin.
\end{itemize}

\begin{lstlisting}
procedure set_delay(self : in out TB6612_record; wait_time : Natural);
\end{lstlisting}
\indexfunc{set\_delay}
Set a time delay between steps to use when stepping the motor a number of steps.  If not needed, it can be set to zero.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $wait\_time$ - The time delay between steps in mS.
\end{itemize}

\begin{lstlisting}
procedure step(self : in out TB6612_record; steps : Integer);
\end{lstlisting}
\indexfunc{step}
Move the stepper motor a specified number of steps.  A negative number will move in the opposite direction as a positive number.  Zero steps will do nothing.  If no delay has been specified, a default of 5mS between steps will be used.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $steps$ - The number of steps to move the motor.
\end{itemize}

\begin{lstlisting}
procedure stepper_off(self : in out TB6612_record);
\end{lstlisting}
\indexfunc{stepper\_off}
De-energize the coils for a stepper motor (or both DC motors).
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
\end{itemize}

\begin{lstlisting}
procedure set_bridge_a(self : in out TB6612_record; value : Integer);
procedure set_bridge_b(self : in out TB6612_record; value : Integer);
\end{lstlisting}
\indexfunc{set\_bridge\_a}
\indexfunc{set\_bridge\_b}
Each of the two H-bridges can be controlled separately.  This would allow two DC motors to be driven.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $value$ - A value of zero sets the bridge off.  A positive value sets the polarity in one direction.  A negative value sets the polarity in the opposite direction.
\end{itemize}

Note that polarities are not specified as they depend on how the hardware is wired.

\subsection{\package{BBS.embed.I2C.ADS1015}}
This is a driver for the Texas Instruments ADS1015 4 channel analog to digital convertor that attaches to an I2C bus \cite{ADS1015}.  This converter has a wide variety of configuration options.  Refer to the datasheet for details.  A number of constants have been defined to support the various configuration options (see Tables \ref{tbl:ADS1015mux}, \ref{tbl:ADS1015PGA}. \ref{tbl:ADS1015DRC}, and \ref{tbl:ADS1015CompQ}).

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Mux Mode Configuration \\
    \hline
    \constant{mux\_a0\_a1} & Difference between AIN0 and AIN1 (default) \\
    \constant{mux\_a0\_a3} & Difference between AIN0 and AIN3 \\
    \constant{mux\_a1\_a3} & Difference between AIN1 and AIN3 \\
    \constant{mux\_a2\_a3} & Difference between AIN2 and AIN3 \\
    \constant{mux\_a0\_gnd} & Single ended AIN0 value \\
    \constant{mux\_a1\_gnd} & Single ended AIN1 value \\
    \constant{mux\_a2\_gnd} & Single ended AIN2 value \\
    \constant{mux\_a3\_gnd} & Single ended AIN3 value \\
  \end{tabular}
  \caption{Constants for ADS1015 Mux Mode Configuration}
  \label{tbl:ADS1015mux}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & PGA Configuration \\
    \hline
    \constant{pga\_6\_144} & Full scale voltage is 6.144V \\
    \constant{pga\_4\_096} & Full scale voltage is 4.096V \\
    \constant{pga\_2\_048} & Full scale voltage is 2.048V (default) \\
    \constant{pga\_1\_024} & Full scale voltage is 1.024V \\
    \constant{pga\_0\_512} & Full scale voltage is 0.512V \\
    \constant{pga\_0\_256} & Full scale voltage is 0.256V \\
  \end{tabular}
  \caption{Constants for ADS1015 Programmable Gain Amplifier Configuration}
  \label{tbl:ADS1015PGA}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Data Rate in Samples per Second (S/S) \\
    \hline
    \constant{dr\_0128} & Data rate is 128S/S \\
    \constant{dr\_0250} & Data rate is 250S/S \\
    \constant{dr\_0490} & Data rate is 490S/S \\
    \constant{dr\_0920} & Data rate is 920S/S \\
    \constant{dr\_1600} & Data rate is 1600S/S (default) \\
    \constant{dr\_2400} & Data rate is 2400S/S \\
    \constant{dr\_3300} & Data rate is 3300S/S \\
  \end{tabular}
  \caption{Constants for ADS1015 Data Rate Configuration}
  \label{tbl:ADS1015DRC}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Comparator Queue Configuration \\
    \hline
    \constant{comp\_que\_1} & Assert after one conversion \\
    \constant{comp\_que\_2} & Assert after two conversions \\
    \constant{comp\_que\_3} & Assert after three conversion \\
    \constant{comp\_que\_d} & Disable comparator (default) \\
  \end{tabular}
  \caption{Constants for ADS1015 Comparator Queue Configuration}
  \label{tbl:ADS1015CompQ}
\end{center}
\end{table}

There are some additional configuration parameters that don't have constants defined.  These just have values of 0 or 1.  See Table \ref{tbl:ADS1015Misc}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Value & Conversion Mode \\
    0 & Continuous conversion mode \\
    1 & Power-down single-shot mode (default) \\
    \hline
    Value & Comparator Mode \\
    0 & Traditional, with hysteresis (default) \\
    1 & Window comparator \\
    \hline
    Value & Comparator Polarity \\
    0 & Active low (default) \\
    1 & Active high \\
    \hline
    Value & Comparator Latching \\
    0 & Non-latching comparator (default) \\
    1 & Latching comparator \\
  \end{tabular}
  \caption{Constants for ADS1015 Miscellaneous Configuration}
  \label{tbl:ADS1015Misc}
\end{center}
\end{table}

The datatype \datatype{ADS1015\_config} is defined as a record containing the configuration values.  It has the following fields:
\begin{itemize}
    \item \datatype{os} - Operational status, used to start a conversion if in single shot mode.  Don't use when setting configuration.
    \item \datatype{mux} - The mux mode (see Table \ref{tbl:ADS1015mux}).
    \item \datatype{pga} - The programmable gain type (see Table \ref{tbl:ADS1015PGA}).
    \item \datatype{mode} - Conversion mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{dr} - The data rate (see Table \ref{tbl:ADS1015DRC}).
    \item \datatype{comp\_mode} - The comparator mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_pol} - The comparator polarity (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_lat} - The comparator latching (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_que} - The comparator queue configuration  (see Table \ref{tbl:ADS1015CompQ}).
\end{itemize}
\indextype{ADS1015\_config}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Initializes the device to the default configuration.
\indexfunc{configure}
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; config : ADS1015_config; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Initialize the device using the specified configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure change_config(self : in out ADS1015_record;
                        config : ADS1015_config; error : out err_code);
\end{lstlisting}
\indexfunc{change\_config}
Changes the device configuration to new values
\begin{itemize}
  \item $self$ - The device to modify.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_mux(self : in out ADS1015_record;
                  mux : mux_mode_type; error : out err_code);
\end{lstlisting}
\indexfunc{set\_mux}
Changes only the mux mode configuration.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $mux$ - The new mux mode configuration value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_gain(self : in out ADS1015_record;
                  gain : pga_type; error : out err_code);
\end{lstlisting}
\indexfunc{set\_gain}
Changes only the converter gain value.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $gain$ - The new gain value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_continuous(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
\indexfunc{set\_continuous}
Sets the converter to operate in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_1shot(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
\indexfunc{set\_1shot}
Sets the converter to operate in single shot mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
\indexfunc{start\_conversion}
Start a conversion when in single shot mode.  No effect in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
function conversion_done(self : in out ADS1015_record; error : out err_code)
    return Boolean;
\end{lstlisting}
\indexfunc{conversion\_done}
Checks if conversion is in progress.  Will always return \constant{False} (conversion in progress) while in continuous mode.  Returns \constant{True} when no conversion is in progress.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns a conversion in progress flag.
\end{itemize}

\begin{lstlisting}
function get_result(self : in out ADS1015_record; error : out err_code)
    return uint12;
\end{lstlisting}
\indexfunc{get\_result}
Returns the conversion value.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns the conversion value
\end{itemize}

\subsection{\package{BBS.embed.i2c.BME280}}
This is a driver for the Bosch BME280 temperature, pressure, and humidity sensor that attaches to an I2C bus \cite{BME280}.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BME280 sensor and is intended for use in the \function{configure} call.

\begin{lstlisting}
procedure configure(self : in out BME280_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure a BME280 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BME280 device to configure.
  \item $port$ - The I2C bus object that the BME280 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : BME280_record; error : out err_code);
\end{lstlisting}
\indexfunc{start\_conversion}
Instruct the BME280 to start converting temperature, pressure, and humidity readings.  These are converted at the same time.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BME280_record; error : out err_code) return boolean;
\end{lstlisting}
\indexfunc{data\_ready}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
procedure read_data(self : in out BME280_record; error : out err_code);
\end{lstlisting}
\indexfunc{read\_data}
Instructs the BME280 to read the converted temperature, pressure, and humidity values into BME280 object and compute calibrated values.  There is less overhead to read all three at once.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure get_raw(self : BME280_record; raw_temp : out uint32;
                  raw_press : out uint32; raw_hum : out uint32);
\end{lstlisting}
\indexfunc{get\_raw}
Return the raw, uncompensated values after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $raw\_temp$ - The raw temperature value.
  \item $raw\_press$ - The raw pressure value.
  \item $raw\_hum$ - The raw humidity value.
\end{itemize}

\begin{lstlisting}
function get_t_fine(self : BME280_record) return int32;
\end{lstlisting}
\indexfunc{get\_t\_fine}
Returns the \package{t\_fine} value after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the \package{t\_fine} value.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return integer;
\end{lstlisting}
\indexfunc{get\_temp}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.01\degree{}C.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of 0.01\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return BBS.units.temp_c;
function get_temp(self : BME280_record) return BBS.units.temp_f;
function get_temp(self : BME280_record) return BBS.units.temp_k;
\end{lstlisting}
\indexfunc{get\_temp}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return integer;
\end{lstlisting}
\indexfunc{get\_press}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is $\frac{1}{256}$Pa.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of $\frac{1}{256}$Pa.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return BBS.units.press_p;
function get_press(self : BME280_record) return BBS.units.press_mb;
function get_press(self : BME280_record) return BBS.units.press_atm;
function get_press(self : BME280_record) return BBS.units.press_inHg;
\end{lstlisting}
\indexfunc{get\_press}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return integer;
\end{lstlisting}
\indexfunc{get\_hum}
Returns the calibrated relative humidity as an \datatype{Integer}.  The LSB unit is $\frac{1}{1024}$\% humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity in units of $\frac{1}{1024}$\% humidity.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return float;
\end{lstlisting}
\indexfunc{get\_hum}
Returns the relative humidity as a percentage relative humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity as a percentage relative humidity.
\end{itemize}

\subsection{\package{BBS.embed.i2c.BMP180}}
This is a driver for the Bosch BMP180 temperature and pressure sensor that attaches to an I2C bus \cite{BMP180}.  It has been discontinued by Bosch and is not recommended for new projects.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BMP180 sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Conversion Kind \\
    \hline
    \constant{cvt\_temp} & Convert Temperature \\
    \constant{cvt\_press0} & Convert pressure with no oversampling \\
    \constant{cvt\_press1} & Convert pressure with oversampling of two \\
    \constant{cvt\_press2} & Convert pressure with oversampling of four  \\
    \constant{cvt\_press3} & Convert pressure with oversampling of eight  \\
  \end{tabular}
  \caption{Constants for BMP180 Conversion Kinds}
  \label{tbl:BMP180Conv}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out BMP180_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure a BMP180 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BMP180 device to configure.
  \item $port$ - The I2C bus object that the BMP180 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out BMP180_record;
                           kind : uint8; error : out err_code);
\end{lstlisting}
\indexfunc{start\_conversion}
Instruct the BMP180 to start converting temperature or pressure.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $kind$ - The kind of conversion to start.  See Table \ref{tbl:BMP180Conv} for options.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BMP180_record; error : out err_code)
   return boolean;
\end{lstlisting}
\indexfunc{data\_ready}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return float;
\end{lstlisting}
\indexfunc{get\_temp}
Returns the calibrated temperature value as a \datatype{Float} in \degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature as a \datatype{Float} in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_temp}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.1\degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_c;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_f;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_k;
\end{lstlisting}
\indexfunc{get\_temp}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.  \item $error$ - The error code from any I2C transactions.

  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_press}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is 1Pa.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_p;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_mb;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_atm;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_inHg;
\end{lstlisting}
\indexfunc{get\_press}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\subsection{\package{BBS.embed.i2c.L3GD20H}}
This is a driver for the STMicrosystems L3GD20H three-axis digital output gyroscope \cite{L3GD20}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the L3GD20H sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{zyx\_or} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{z\_or} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{y\_or} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{x\_or} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{zyxda} & X,Y,Z axis new data available \\
    \constant{zda} & Z axis new data available \\
    \constant{yda} & Y axis new data available \\
    \constant{xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for L3GD20H Status}
  \label{tbl:L3GD20HStat}
\end{center}
\end{table}

\begin{lstlisting}
type rotations is
   record
      x : integer;
      y : integer;
      z : integer;
   end record;
\end{lstlisting}
\indextype{rotations}
The datatype \datatype{rotations} is a record that holds the raw rotation values from the X, Y, and Z sensors.

\begin{lstlisting}
type rotations_dps is
   record
      x : BBS.units.rot_d_s;
      y : BBS.units.rot_d_s;
      z : BBS.units.rot_d_s;
   end record;
\end{lstlisting}
The datatype \datatype{rotations\_dps} is a record that holds the rotation values in degrees per second from the X, Y, and Z sensors.
\indextype{rotations\_dps}

\begin{lstlisting}
type fsd is (fs_245dps, fs_500dps, fs_2000dps);
\end{lstlisting}
\indextype{fsd}
The datatype \datatype{fsd} is used to select the maximum rotation. The possible values are 245\degree{}/S, 500\degree{}/S, and 2000\degree{}/S.

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; deflection : uint8; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $deflection$ - Set the full-scale deflection (See constants in Table \ref{tbl:L3GD20HDef}).
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_temp(self : L3GD20H_record; error : out err_code)
    return integer;
\end{lstlisting}
\indexfunc{get\_temp}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_rotation\_x}
\indexfunc{get\_rotation\_y}
\indexfunc{get\_rotation\_z}
Return the rotation around the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations;
\end{lstlisting}
\indexfunc{get\_rotations}
Return a \datatype{rotations} record containing the raw sensor values for the rotations around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_temp(self : L3GD20H_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
\indexfunc{get\_temp}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
\end{lstlisting}
\indexfunc{get\_rotation\_x}
\indexfunc{get\_rotation\_y}
\indexfunc{get\_rotation\_z}
Return the rotation around the specified axis, $x$, $y$, or $z$ as a \datatype{rotations\_dps} containing the rotation in \degree{}/S.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations_dps;
\end{lstlisting}
\indexfunc{get\_rotations}
Return a \datatype{otations\_dps} record containing the rotation in \degree{}/S around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_status(self : L3GD20H_record; error : out err_code)
   return uint8;
\end{lstlisting}
\indexfunc{get\_status}
Return the device status.  The constants in Table \ref{tbl:L3GD20HStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function data_ready(self : L3GD20H_record; error : out err_code)
   return boolean;
\end{lstlisting}
\indexfunc{data\_ready}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
 function measure_offsets(self : in out L3GD20H_record) return boolean;
\end{lstlisting}
\indexfunc{measure\_offsets}
When stationary, the sensors may not report 0.  This function should be called when the sensor is stationary.  It reads the rotations several times and averages the results.  This is used to calculate offset values.  The offset values are used when returning the rotations in \datatype{rotations\_dps}.

This function returns \constant{True} if the measurement was successful - that is all of the values measured are reasonably close to the mean.  If it returns false, the sensor may be moving.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the offset measurement was successful.
\end{itemize}

\subsection{\package{BBS.embed.i2c.LSM303DLHC}}
This is a driver for the STMicrosystems LSM303DLHC three-axis digital output gyroscope \cite{LSM303DLHC}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr\_accel} is the I2C address of the LSM303DLHC accelerometer sensor; the constant \constant{addr\_mag} is the I2C address of the magnetometer sensor.  They are intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fs\_2g} & Full scale is 2G (default) \\
    \constant{fs\_4g} & Full scale is 4G \\
    \constant{fs\_8g} & Full scale is 8G \\
    \constant{fs\_16gs} & Full scale is 16G \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Accelerometer}
  \label{tbl:LSM303DLHCafs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{accel\_stat\_zyxor} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zor} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_yor} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_xorr} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zyxda} & X,Y,Z axis new data available \\
    \constant{accel\_stat\_zda} & Z axis new data available \\
    \constant{accel\_stat\_yda} & Y axis new data available \\
    \constant{accel\_stat\_xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Accelerometer Status}
  \label{tbl:LSM303DLHCaStat}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fa\_1\_3\_gauss} & Full scale is 1.3 gauss \\
    \constant{fs\_1\_9\_gauss} & Full scale is 1.9 gauss \\
    \constant{fs\_2\_5\_gauss} & Full scale is 2.5 gauss \\
    \constant{fs\_4\_0\_gauss} & Full scale is 4.0 gauss\\
    \constant{fs\_4\_7\_gauss} & Full scale is 4.7 gauss \\
    \constant{fs\_5\_6\_gauss} & Full scale is 5.6 gauss \\
    \constant{fs\_8\_1\_gauss} & Full scale is 8.1 gauss\\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Magnetometer}
  \label{tbl:LSM303DLHCmfs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{mag\_lock} & Data output register lock. \\
    \constant{mag\_drdy} & Data ready \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Magnetometer Status}
  \label{tbl:LSM303DLHCmStat}
\end{center}
\end{table}

Two utility datatypes are defined for holding accelerations.  The first,  \datatype{accelerations} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw acceleration values from the sensor.  The second, \datatype{accelerations\_g} is similar, but the components are all of type \datatype{BBS.units.accel\_g} for acceleration in units on 1 earth gravity.
\indextype{accelerations}
\indextype{accelerations\_g}

Two utility datatypes are defined for holding magnetic fields.  The first,  \datatype{magnetism} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw magnetometer values from the sensor.  The second, \datatype{magnetism\_gauss} is similar, but the components are all of type \datatype{BBS.units.mag\_g} for magnetism in units on 1 gauss.
\indextype{magnetism}
\indextype{magnetism\_gauss}

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record; port : i2c_interface;
                    accel : addr7; mag : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $accel$ - The I2C address of the device accelerometer.
  \item $mag$ - The I2C address of the device magnetometer.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record;
                    port : i2c_interface; addr_accel : addr7; addr_mag : addr7;
                    accel_fs : uint8; mag_fs : uint8; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $addr\_accel$ - The I2C address of the device accelerometer.
  \item $addr\_mag$ - The I2C address of the device magnetometer.
  \item $accel\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCafs}.
  \item $mag\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCmfs}.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure calibrate_accel(self : in out LSM303DLHC_record);
\end{lstlisting}
\indexfunc{calibrate\_accel}
The \function{calibrate\_accel} procedure can be called when the sensor is stationary in a 1G acceleration or gravitational field.  It takes multiple measurements of the X, Y, and Z acceleration and computes the average of $X^2 + Y^2 + Z^2$.  This value should be 1.0.  A more sophisticated approach would be to compute a calibration value for each of the axis separately, but that would require the sensor to be precisely positioned three time.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to calibrate.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_acceleration\_x}
\indexfunc{get\_acceleration\_y}
\indexfunc{get\_acceleration\_z}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations;
\end{lstlisting}
\indexfunc{get\_accelerations}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
\end{lstlisting}
\indexfunc{get\_acceleration\_x}
\indexfunc{get\_acceleration\_y}
\indexfunc{get\_acceleration\_z}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.accel\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.accel\_g} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations_g;
\end{lstlisting}
\indexfunc{get\_accelerations}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations\_g} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_accel_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
\indexfunc{get\_accel\_status}
Return the accelerometer status.  The constants in Table \ref{tbl:LSM303DLHCaStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function accel_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
\indexfunc{accel\_data\_ready}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
function get_temp(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_temp}
Return the device temperature as an \datatype{Integer} in units of $\frac{1}{8}$\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in units of $\frac{1}{8}$\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : LSM303DLHC_record; error : out err_code)
   return float;
\end{lstlisting}
\indexfunc{get\_temp}
Return the device temperature as a \datatype{Float} in units of 1\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{Float} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
\indexfunc{get\_temp}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
\indexfunc{get\_magnet\_x}
\indexfunc{get\_magnet\_y}
\indexfunc{get\_magnet\_z}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the magnetic field along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism;
\end{lstlisting}
\indexfunc{get\_magnetism}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
\end{lstlisting}
\indexfunc{get\_magnet\_x}
\indexfunc{get\_magnet\_y}
\indexfunc{get\_magnet\_z}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.mag\_g} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{BBS.units.mag\_g} representing the magnetic field along the specified axis in units of gauss.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism_gauss;
\end{lstlisting}
\indexfunc{get\_magnetism}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism\_gauss} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism\_gauss} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_mag_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
\indexfunc{get\_mag\_status}
Return the magnetometer status.  The constants in Table \ref{tbl:LSM303DLHCmStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function mag_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
\indexfunc{mag\_data\_ready}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP4725}}
This is a driver for the Microchip MCP4725 digital to analog convertor that attaches to an I2C bus \cite{MCP4725}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Command \\
    \hline
    \constant{Fast\_Write} & Fast write. \\
    \constant{Write\_CMD} & Write CMD. \\
    \constant{Write\_EEPROM} & Write EEPROM. \\
  \end{tabular}
  \caption{Constants for MCP4725 Commands}
  \label{tbl:MCP4725cmd}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Power-Down Mode \\
    \hline
    \constant{PD\_Normal} & Normal mode. \\
    \constant{PD\_1k} & 1k$\Omega$ to ground. \\
    \constant{PD\_100k} & 100k$\Omega$ to ground. \\
    \constant{PD\_500k} & 500k$\Omega$ to ground. \\
  \end{tabular}
  \caption{Constants for MCP4725 Power-Down Modes}
  \label{tbl:MCP4725pdm}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out MCP4725_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the MCP4725 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP4725 device to configure.
  \item $port$ - The I2C bus object that the MCP4725 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; value : uint12;
              err : out err_code);
\end{lstlisting}
\indexfunc{set}
The DAC is only single channel, so this just sets the value using fast write and PD normal mode.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $value$ - The output value to use for the DAC.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; cmd : CMD_type; mode : Mode_type;
              value : uint12; err : out err_code);
\end{lstlisting}
\indexfunc{set}
General set command.  Use the defined constants for the command and mode.  Other values may cause unexpected behavior.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $cmd$ - The command to use.  See Table \ref{tbl:MCP4725cmd} for available commands.
  \item $mode$ - The power-down mode to use.  See Table \ref{tbl:MCP4725pdm} for available modes.
  \item $value$ - The output value to use for the command and mode.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23008}}
This is a driver for the Microchip MCP23008 8-bit I/O port extender\cite{MCP23008}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCB23008_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the MCP23008 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $port$ - The I2C bus object that the MCP23008 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCB23008_record; dir : uint8;
                  error : out err_code);
\end{lstlisting}
\indexfunc{set\_dir}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $dir$ - The \datatype{uint8} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCB23008_record; data : uint8;
                   error : out err_code);
\end{lstlisting}
\indexfunc{set\_data}
Sets the output bits.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $data$ - The \datatype{uint8} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function read_data(self : MCB23008_record; error : out err_code)
   return uint8;
\end{lstlisting}
\indexfunc{read\_data}
Read the port.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint8}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23017}}
This is a driver for the Microchip MCP23017 8-bit I/O port extender\cite{MCP23017}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCP23017_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the MCP23017 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $port$ - The I2C bus object that the MCP23017 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function present(port : i2c_interface;
                 addr : addr7) return boolean;
\end{lstlisting}
\indexfunc{present}
Check to see if a MCP23017 is present at the specified I2C address.  First it checks if the address is in the range for the MCP23017 and then if a read of one of the device registers completes successfully.
\begin{itemize}
  \item $port$ - The I2C bus object that the MCP23017 is connected to.
  \item $addr$ - The I2C address of the device to check.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
\indexfunc{set\_dir}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_dir(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
\indexfunc{get\_dir}
Read the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the direction bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_polarity(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
\indexfunc{set\_polarity}
Set the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the polarity bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_polarity(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
\indexfunc{get\_polarity}
Read the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the polarity bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_pullup(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
\indexfunc{set\_pullup}
Enable/Disable weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the pullup bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_pullup(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
\indexfunc{get\_pullup}
Read weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pullup bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCP23017_record; data : uint16;
                   error : out err_code);
\end{lstlisting}
\indexfunc{set\_data}
Sets the output bits.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to set.
  \item $data$ - The \datatype{uint16} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_data(self : MCP23017_record; error : out err_code)
                   return uint16;
\end{lstlisting}
\indexfunc{get\_data}
Read the port.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint16}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.PCA9685}}
This is a driver for the NXP Semiconductors PCA9685 16-channel, 12-bit PWM with I2C bus LED controller\cite{PCA9685}.  The driver does not support all of the options that the device has, but these can be added if needed.  The device can be configured to respond to one of four different I2C addresses.  The constants \constant{addr\_0} through \constant{addr\_3} are defined for these addresses.

In addition to controlling LEDs, it can control other PWM devices such as servo motors.  Note that LED brightness is controlled by the duty cycle and any duty cycle is valid.  Servos are controlled by the pulse width which should range from 1.5 to 2.5 mS.  See Table \ref{tbl:PCA9685Servo} for some measured values.  Note that all measured numbers are approximate.  There are probably a few  counts left before hitting full scale movement.  It's also entirely possible  that these values may vary with time, temperature, or other factors.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l|l}
    Servo & Min-position & Max-position \\
    \hline
    SG90 & 500mS & 2100mS \\
    SG99 & 450mS & 2050mS \\
    SG5010 & 500mS & 2100mS \\
  \end{tabular}
  \caption{Measured Values for PCA9685 Controlling Servos}
  \label{tbl:PCA9685Servo}
\end{center}
\end{table}

There are some things to keep in mind:
\begin{enumerate}
  \item Test your own servos to determine their appropriate values.
  \item If you want any sort of precision, you need some sort of position feed-back to the program.
  \item The documentation that says that the pulse width for servos should range from 1.5 to 2.5 mS may not be accurate.
\end{enumerate}

PWM channels are 0 to 15.  Channel 16 is the all call channel.  For each channel there is a 12 bit counter and two thresholds: the on and the off threshold.  When the counter is equal to the on threshold, the output turns on.  When the counter is equal to the off threshold, the output turns off.  This allows the pulses to be staggered between the channels, if needed.

For driving servo motors, the \datatype{servo\_range} datatype is defined as a \datatype{Float} with a range from -1.0 to 1.0.  Once the \function{set\_servo\_range} procedure has been called, the \function{set\_servo} procedure can be used to set the servo position using \datatype{servo\_range} rather than figuring out the settings for the duty cycle.  Thus, when changing between servos with different characteristics, all that needs to change is the \function{set\_servo\_range} call.
\indextype{servo\_range}

\begin{lstlisting}
procedure configure(self : in out PS9685_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
\indexfunc{configure}
Called to configure the PCA9685 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $port$ - The I2C bus object that the PCA9685 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : PS9685_record; chan : channel;
              on : uint12; off : uint12; error : out err_code);
\end{lstlisting}
\indexfunc{set}
Set on and off times for a specific channel.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $on$ - The on time for the channel.
  \item $off$ - The off time for the channel.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_full_on(self : PS9685_record; chan : channel;
                      error : out err_code);
\end{lstlisting}
\indexfunc{set\_full\_on}
Sets the specified channel to full on.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_full_off(self : PS9685_record; chan : channel;
                       error : out err_code);
\end{lstlisting}
\indexfunc{set\_full\_off}
Sets the specified channel to full off.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure sleep(self : PS9685_record; state : boolean;
                error : out err_code);
\end{lstlisting}
\indexfunc{sleep}
If state is \constant{True}, send the device to sleep, otherwise wake it up.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $state$ - \constant{True} for sleep, \constant{False} for wake.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_servo_range(self : in out PS9685_record; chan : channel;
                          min : uint12; max : uint12);
\end{lstlisting}
\indexfunc{set\_servo\_range}
Sets the maximum and minimum duty cycles for a channel.  Once these are set, a servo motor can be controlled using the \function{set\_servo} procedure using a servo position in the range on -1.0 to 1.0.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $min$ - The minimum duty cycle for the servo, corresponding to servo position -1.0.
  \item $max$ - The maximum duty cycle for the servo, corresponding to servo position 1.0.
\end{itemize}

\begin{lstlisting}
procedure set_servo(self : PS9685_record; chan : channel;
                    position : servo_range; error : out err_code);
\end{lstlisting}
\indexfunc{set\_servo}
Once the servo range has been set by the \function{set\_servo\_range} procedure, the servo can be controlled by this function using a servo position from -1.0 to 1.0 rather than the duty cycle.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $position$ - The servo position in a range from -1.0 to 1.0.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\subsection{\package{BBS.embed.SPI.RA8875}}
This is the driver for the RAiO RA8875 LCD controller that attaches to the SPI bus\cite{RA8875}.  There are a couple of hardware considerations.  First, it appears that the RA8875 does not tri-state its SPI output, which means that it doesn't work well with other devices on the SPI bus.  This can be fixed by adding a tri-state buffer.  Second, while the RA8875 operates at 3.3V, the LCD I used requires 5V for the backlight.  This is not insurmountable, but something to be aware of.

The intention of this driver is to provide an Ada interface to the various text and graphics primitives offered by the RA8875.  While it works, it still needs some work and should be considered to be experimental.  Use at your own risk, or you can use this as a starting point for writing your own driver.

There are a number of constants defined.  I expect that most of these are used internal to the driver and should be moved out of the spec.  There are also some types that are used in the API.  These are documented below.

\begin{lstlisting}
type RA8875_sizes is (RA8875_480x272, RA8875_800x480);
\end{lstlisting}
\indextype{RA8875\_sizes}
The datatype \datatype{RA8875\_sizes} is an enumeration defined for the screen sizes supported by the RA8875.  The sizes supported by the RA8875 are 320x240, 320x480, 480x272, 640x480, and 800x480.  Right now I only have an 800x480 panel for testing so nothing is tested for other sizes.

\begin{lstlisting}
type RA8875_LAYER is (LAYER1, LAYER2);
\end{lstlisting}
\indextype{RA8875\_LAYER}
The datatype \datatype{RA8875\_LAYER} is used to select the currently active layer for the display.  In some configurations, only one layer is allowed and this option is ignored.

\begin{lstlisting}
type RA8875_MWCR0_MODE is (graphic, text);
\end{lstlisting}
\indextype{RA8875\_MWCR0\_MODE}
The datatype \datatype{RA8875\_MWCR0\_MODE} is used to determine if the RA8875 is operating in text mode or graphics mode.

\begin{lstlisting}
type RA8875_MWCR0_CURDIR is (LRTD, RLTD, TDLR, DTLR);
\end{lstlisting}
\indextype{RA8875\_MWCR0\_CURDIR}
The datatype \datatype{RA8875\_MWCR0\_CURDIR} is used to determine the memory write direction for graphics mode.  The options are left to right top down (\constant{LRTD}), right to left top down (\constant{RLTD}), top down left to right (\constant{TDLR}), and down to top left to right (\constant {DTLR}).

\begin{lstlisting}
type RA8875_MWCR1_GCURS_ENABLE is (disable, enable);
\end{lstlisting}
\indextype{RA8875\_MWCR1\_GCURS\_ENABLE}
The datatype \datatype{RA8875\_MWCR1\_GCURS\_ENABLE} is used to determine if the graphics cursor should be enabled or disabled.

\begin{lstlisting}
type RA8875_MWCR1_GCURS_SET is range 0 .. 7;
\end{lstlisting}
\indextype{RA8875\_MWCR1\_GCURS\_SET}
The datatype \datatype{RA8875\_MWCR1\_GCURS\_SET} is used to select which set of graphics cursors to use.

\begin{lstlisting}
type RA8875_MWCR1_WRITE_DEST is (LAYER, CGRAM, GCURS, PATTERN);
\end{lstlisting}
\indextype{RA8875\_MWCR1\_WRITE\_DEST}
The datatype \datatype{RA8875\_MWCR1\_WRITE\_DEST} is used to select the destination for graphics writing.

\begin{lstlisting}
type R5G6B5_color is record
   R : uint8 range 0 .. 31;
   G : uint8 range 0 .. 63;
   B : uint8 range 0 .. 31;
end record;
\end{lstlisting}
\indextype{R5G6B5\_color}
The datatype \datatype{R5G6B5\_color} is used to represent colors with five bits for the red, six bits for the green, and five bits for the blue channels.  This adds up to sixteen bits.

\begin{lstlisting}
   type R3G3B2_color is record
      R : uint8 range 0 .. 7;
      G : uint8 range 0 .. 7;
      B : uint8 range 0 .. 3;
   end record
     with pack, size => 8;
   for R3G3B2_color use
      record
         B at 0 range 0 .. 1;
         G at 0 range 2 .. 4;
         R at 0 range 5 .. 7;
      end record;
\begin{lstlisting}
\indextype{R3G3B2\_color}
The datatype \datatype{R3G3B2\_color} is used to represent colors with three bits for red, three bits for green and two bits for blue.  This adds up to eight bits.

\begin{lstlisting}
type RA8875_FNCR0_Code_Page is
     (RA8875_FNCR0_ISO8859_1, RA8875_FNCR0_ISO8859_2,
      RA8875_FNCR0_ISO8859_3, RA8875_FNCR0_ISO8859_4);
\end{lstlisting}
\indextype{RA8875\_FNCR0\_Code\_Page}
The datatype \datatype{RA8875\_FNCR0\_Code\_Page} is used to select which code page to use when translating character codes to glyphs on the display.

\begin{lstlisting}
type RA8875_ELLIPSE_PART is (RA8875_ELLIPSE_LL, RA8875_ELLIPSE_UL,
                             RA8875_ELLIPSE_UR, RA8875_ELLIPSE_LR);
\end{lstlisting}
\indextype{RA8875\_ELLIPSE\_PART}
The datatype \datatype{RA8875\_ELLIPSE\_PART} is used to select which part of an ellipse is drawn.  The options are lower-left (\constant{RA8875\_ELLIPSE\_LL}), upper-left (\constant{RA8875\_ELLIPSE\_UL}), upper-right (\constant{RA8875\_ELLIPSE\_UR}), and lower-right (\constant{RA8875\_ELLIPSE\_LR}).

\begin{lstlisting}
type RA8875_LTPR0_SCROLL_MODE is (LAYER12_SIMULTANEOUS, LAYER1_ONLY,
                                  LAYER2_ONLY, BUFFERED);
\end{lstlisting}
\indextype{RA8875\_LTPR0\_SCROLL\_MODE}
The datatype \datatype{RA8875\_LTPR0\_SCROLL\_MODE} is used to identify the mode for scrolling.  Both layers can be scrolled simultaneously, either of the two layers can be selected to scroll independently, or layer 2 can be used as a scroll buffer.

\begin{lstlisting}
type RA8875_LTPR0_DISP_MODE is (ONLY_LAYER1, ONLY_LAYER2, LIGHTEN, TRANSPARENT,
                                  BOOL_OR, BOOL_AND, FLOATING, RESERVED);
\end{lstlisting}
\indextype{RA8875\_LTPR0\_DISP\_MODE}
The datatype \datatype{RA8875\_LTPR0\_DISP\_MODE} is used to identify the way to display the two layers.  Each layer can be displayed by itself or in various combinations.

\begin{lstlisting}
   type RA8875_GCursor is array (0 .. 31, 0 .. 31) of integer range 0 .. 3
     with Pack;
\end{lstlisting}
\indextype{RA8875\_GCursor}
The datatype \datatype{RA8875\_GCursor} represents a bitmap for the graphics cursor.  The pixel values are:
\begin{itemize}
  \item 0 - GCC0 color
  \item 1 - GCC1 color
  \item 2 - Background color
  \item 3 - Inverse of background color
\end{itemize}
Note that the coordinates for GCursor are reversed from what one would expect.  The Y axis coordinate is the first array index and the X axis coordinate is the second array index.  One can think of it as being in row, column order.

The API is documented below.

\subsubsection{Low Level Methods}
These are primarily intended for supporting the other, higher level routines.
\begin{lstlisting}
procedure setup(self : in out RA8875_record; CS : GPIO.GPIO; screen : SPI_ptr);
\end{lstlisting}
\indexfunc{setup}
Initialize and configure the RA8875 device.  Use this is no hardware reset GPIO is connected
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $CS$ - The GPIO used as the device chip select.
  \item $screen$ - The SPI bus that the RA8875 is connected to.
\end{itemize}

\begin{lstlisting}
procedure setup(self : in out RA8875_record; CS : GPIO.GPIO;
                RST : GPIO.GPIO; screen : SPI_ptr);
\end{lstlisting}
\indexfunc{setup}
Initialize and configure the RA8875 device.  Use this if a GPIO is connected to use as a hardware reset.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $CS$ - The GPIO used as the device chip select.
  \item $RST$ - The GPIO used as a hardware reset.
  \item $screen$ - The SPI bus that the RA8875 is connected to.
\end{itemize}

\begin{lstlisting}
procedure hwReset(self : in out RA8875_record);
\end{lstlisting}
\indexfunc{hwReset}
Send a hardware reset command to the RA8875, if a GPIO has been assigned for hardware reset.  Otherwise, it does nothing.
\begin{itemize}
  \item $self$ - The RA8875 device to reset.
\end{itemize}

\begin{lstlisting}
procedure swReset(self : in out RA8875_record);
\end{lstlisting}
\indexfunc{swReset}
Send a software reset command to the RA8875.  This can be done even if no hardware reset GPIO has been configured.
\begin{itemize}
  \item $self$ - The RA8875 device to reset.
\end{itemize}

\begin{lstlisting}
procedure writeCmd(self : RA8875_record; value : uint8);
\end{lstlisting}
\indexfunc{writeCmd}
Send a command to the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to send a command to.
  \item $value$ - The command as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
procedure writeData(self : RA8875_record; value : uint8);
\end{lstlisting}
\indexfunc{writeData}
Send data to the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to send data to.
  \item $value$ - The data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
function readStatus(self : RA8875_record) return uint8;
\end{lstlisting}
\indexfunc{readStatus}
Read a status value from the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to get status from.
  \item Returns the status as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
function readData(self : RA8875_record) return uint8;
\end{lstlisting}
\indexfunc{readData}
Read data from the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to get data from.
  \item Returns the data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
procedure writeReg(self : RA8875_record; reg : uint8; value : uint8);
\end{lstlisting}
\indexfunc{writeReg}
Writes data to a RA8875 register.
\begin{itemize}
  \item $self$ - The RA8875 device containing the register.
  \item $reg$ - The register number as a \datatype{uint8}.
  \item $value$ - The data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
   function readReg(self : RA8875_record; reg : uint8) return uint8;
\end{lstlisting}
\indexfunc{readReg}
Reads data from a RA8875 register.
\begin{itemize}
  \item $self$ - The RA8875 device containing the register.
  \item $reg$ - The register number as a \datatype{uint8}.
  \item Returns the data as a \datatype{uint8}.
\end{itemize}

\subsubsection{Configuration Methods}
\begin{lstlisting}
procedure configure(self : in out RA8875_record; size : RA8875_sizes);
\end{lstlisting}
\indexfunc{configure}
Configures the LCD size for use by the RA8875.  Currently only 480x272 and 800x480 are supported and only 800x480 has been tested.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $size$ - The LCD size as a \datatype{RA8875\_sizes}.
\end{itemize}

\begin{lstlisting}
procedure setSleep(self : RA8875_record; state : boolean);
\end{lstlisting}
\indexfunc{setSleep}
Sets the sleep state of the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - If \constant{True}, puts the RA8875 to sleep and turns the display off.  If \constant{False} just turns the display off.
\end{itemize}

\begin{lstlisting}
procedure setDisplay(self : RA8875_record; state : boolean);
\end{lstlisting}
\indexfunc{setDisplay}
Turns the display on or off.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - If \constant{True}, turns the display on.  If \constant{False} turns the display off.
\end{itemize}

\begin{lstlisting}
procedure GPIOX(self : RA8875_record; state : boolean);
\end{lstlisting}
\indexfunc{GPIOX}
Set the state of the GPIOX pin.  This is apparently used in the AdaFruit breakout board, though I'm not sure what it's used for.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the GPIOX pin on or off.
\end{itemize}

\begin{lstlisting}
procedure PWM1config(self : RA8875_record; state : boolean; clock : uint8);
\end{lstlisting}
\indexfunc{PWM1config}
Configures PWM channel 1.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the PWM Channel 1 to disable (\constant{False}) or enable (\constant{True}).
  \item $clock$ - Sets the clock divide ratio.
\end{itemize}

\begin{lstlisting}
procedure PWM2config(self : RA8875_record; state : boolean; clock : uint8);
\end{lstlisting}
\indexfunc{PWM2config}
Configures PWM channel 2.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the PWM Channel 2 to disable (\constant{False}) or enable (\constant{True}).
  \item $clock$ - Sets the clock divide ratio.
\end{itemize}

\begin{lstlisting}
procedure PWM1out(self : RA8875_record; value : uint8);
\end{lstlisting}
\indexfunc{PWM1out}
Sets PWM channel 1 duty cycle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $value$ - Sets the duty cycle of PWM Channel 1 in units of $\frac{1}{256}$.
\end{itemize}

\begin{lstlisting}
procedure PWM2out(self : RA8875_record; value : uint8);
\end{lstlisting}
\indexfunc{PWM2out}
Sets PWM channel 1 duty cycle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $value$ - Sets the duty cycle of PWM Channel 1 in units of $\frac{1}{256}$.
\end{itemize}

\begin{lstlisting}
procedure setDisplayCtrl(self : RA8875_record; layer : uint8; hdir : uint8;
                         vdir : uint8);
\end{lstlisting}
\indexfunc{setDisplayCtrl}
Sets some of the RA8875 display control parameters.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $layer$ - 0 For one layer configuration, 128 for two layer configuration.
  \item $hdir$ - 0 For increasing SEG number, 8 for decreasing SEG number.
  \item $vdir$ - 0 For increasing COM number, 4 for decreasing COM number.
\end{itemize}

\begin{lstlisting}
procedure setWriteCtrl0(self : RA8875_record; mode : RA8875_MWCR0_MODE;
                        cursorVisible : boolean; cursorBlink : boolean;
                        writeDir : RA8875_MWCR0_CURDIR;
                        WriteCursorIncr : boolean; ReadCursorIncr : boolean);
\end{lstlisting}
\indexfunc{setWriteCtrl0}
Configures the RA8875 memory write control register 0.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $mode$ - Text or graphics mode.
  \item $cursorVisible$ - Set to \constant{True} to make the cursor visible.
  \item $cursorBlink$ - Set to \constant{True} to make the cursor blink.
  \item $writeDir$ - The direction to write data in graphics mode.
  \item $WriteCursorIncr$ - Set to \constant{True} to increment the cursor when writing memory.
  \item $ReadCursorIncr$ - Set to \constant{True} to increment the cursor when reading memory.
\end{itemize}

\begin{lstlisting}
procedure setWriteCtrl1(self : RA8875_record;
                        cursorEnable : RA8875_MWCR1_GCURS_ENABLE;
                        GCursorSelect : RA8875_MWCR1_GCURS_SET;
                        writeDest : RA8875_MWCR1_WRITE_DEST;
                        layer : RA8875_LAYER);
\end{lstlisting}
\indexfunc{setWriteCtrl1}
Configures the RA8875 memory write control register 1.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $cursorEnable$ - Selects if the graphics cursor is enabled or not.
  \item $GCursorSelect$ - Selects which graphics cursor to use.
  \item $writeDest$ - Selects the destination for graphics writing.
  \item $writeDir$ - The direction to write data in graphics mode.
  \item $layer$ - Selects the layer for graphics writing (used only if the resolution is $\le$480x4000 or the color depth is 8 bits/pixel).
\end{itemize}

\subsubsection{Text Methods}
\begin{lstlisting}
procedure textMode(self : RA8875_record);
\end{lstlisting}
\indexfunc{textMode}
Sets the RA8875 to text mode.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
\end{itemize}

\begin{lstlisting}
procedure textColor(self : RA8875_record; bg : R5G6B5_color; fg : R5G6B5_color);
\end{lstlisting}
\indexfunc{textColor}
Sets the foreground and background color for text.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $bg$ - The background color.
  \item $fg$ - The foreground color.
\end{itemize}

\begin{lstlisting}
procedure textSetCodePage(self : RA8875_record; page : RA8875_FNCR0_Code_Page);
\end{lstlisting}
\indexfunc{textSetCodePage}
Selects the code page to used when translating character codes to glyphs on the screen.  The options are: \constant{RA8875\_FNCR0\_ISO8859\_1}, \constant{RA8875\_FNCR0\_ISO8859\_2}, \constant{RA8875\_FNCR0\_ISO8859\_3}, and \constant{RA8875\_FNCR0\_ISO8859\_4}.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $page$ - The code page to use.
\end{itemize}

\begin{lstlisting}
procedure textSetAttribute(self : RA8875_record; align : boolean;
                              transparent : boolean;
                              rotate : boolean; h_size : uint8; v_size : uint8);
\end{lstlisting}
\indexfunc{textSetAttribute}
Sets the attributes in the font control register for drawing text.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $align$ - Enables or disables text alignment.
  \item $transparent$ - If \constant{True}, the background is transparent instead of the background color.
  \item $rotate$ - If \constant{True}, rotate text by 90$\degree{}$.
  \item $h\_size$ - Horizontal size scale factor (1 .. 4).
  \item $v\_size$ - Vertical size scale factor (1 .. 4).
\end{itemize}

\begin{lstlisting}
procedure textSetLineHeight(self : RA8875_record; size : uint8);
\end{lstlisting}
\indexfunc{textSetLineHeight}
Set the font line distance setting.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $size$ - The distance between lines of text in pixels.
\end{itemize}

\begin{lstlisting}
procedure textSetFontWidth(self : RA8875_record; size : uint8);
\end{lstlisting}
\indexfunc{textSetFontWidth}
Set the spacing between characters in pixels.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $size$ - The distance between characters in pixels.
\end{itemize}

\begin{lstlisting}
procedure textWrite(self : RA8875_record; str : string);
\end{lstlisting}
\indexfunc{textWrite}
Writes a string of text to the display using the currently selected attributes.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $str$ - The text to write.
\end{itemize}

\subsubsection{Graphics Methods}
\begin{lstlisting}
procedure graphicsMode(self : RA8875_record);
\end{lstlisting}
\indexfunc{graphicsMode}
Sets the RA8875 to graphics mode.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
\end{itemize}

\begin{lstlisting}
procedure drawColor(self : RA8875_record; color : R5G6B5_color);
\end{lstlisting}
\indexfunc{drawColor}
Set the color for drawing graphics.  The graphics commands will use this color until it is changed.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $color$ - The color to draw.
\end{itemize}

\begin{lstlisting}
procedure drawRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                   y2 : uint16; fill : boolean);
\end{lstlisting}
\indexfunc{drawRect}
Draws a rectangle on the display.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one corner.
  \item $y1$ - The Y-coordinate of one corner.
  \item $x2$ - The opposite X-coordinate.
  \item $y2$ - The opposite Y-coordinate.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawRndRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16; rad : uint16; fill : boolean);
\end{lstlisting}
\indexfunc{drawRndRect}
Draws a rectangle on the display.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one corner.
  \item $y1$ - The Y-coordinate of one corner.
  \item $x2$ - The opposite X-coordinate.
  \item $y2$ - The opposite Y-coordinate.
  \item $rad$ - The radius of the corner curves.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawLine(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                   y2 : uint16);
\end{lstlisting}
\indexfunc{drawLine}
Draw a line between two points.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one end of the line.
  \item $y1$ - The Y-coordinate of one end of the line.
  \item $x2$ - The X-coordinate of the other end of the line.
  \item $y2$ - The Y-coordinate of the other end of the line.
\end{itemize}

\begin{lstlisting}
procedure drawCircle(self : RA8875_record; x : uint16; y : uint16; rad : uint16;
                     fill : boolean);
\end{lstlisting}
\indexfunc{drawCircle}
Draw a circle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $rad$ - The radius of the circle.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawTriangle(self : RA8875_record; x1 : uint16; y1 : uint16;
                       x2 : uint16; y2 : uint16; x3 : uint16; y3 : uint16;
                       fill : boolean);
\end{lstlisting}
\indexfunc{drawTriangle}
Draw a triangle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of the first point.
  \item $y1$ - The Y-coordinate of the first point.
  \item $x2$ - The X-coordinate of the second point.
  \item $y2$ - The Y-coordinate of the second point.
  \item $x3$ - The X-coordinate of the third point.
  \item $y3$ - The Y-coordinate of the third point.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawEllipse(self : RA8875_record; x : uint16; y : uint16;
                     hRad : uint16; vRad : uint16; fill : boolean);
\end{lstlisting}
\indexfunc{drawEllipse}
Draw an ellipse oriented either horizontally or vertically.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $hRad$ - The radius in the horizontal direction.
  \item $vRad$ - The radius in the vertical direction.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawEllipseSegment(self : RA8875_record; x : uint16; y : uint16;
                             hRad : uint16;  vRad : uint16;
                             seg : RA8875_ELLIPSE_PART; fill : boolean);
\end{lstlisting}
\indexfunc{drawEllipseSegment}
Draw a segment of an ellipse oriented either horizontally or vertically.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $hRad$ - The radius in the horizontal direction.
  \item $vRad$ - The radius in the vertical direction.
  \item $seg$ - Which segment to draw.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                   y2 : uint16; color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawRect}
Draws a rectangle on the display.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one corner.
  \item $y1$ - The Y-coordinate of one corner.
  \item $x2$ - The opposite X-coordinate.
  \item $y2$ - The opposite Y-coordinate.
  \item $color$ - The color for the rectangle.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawRndRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                   y2 : uint16; rad : uint16; color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawRndRect}
Draws a rectangle on the display.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one corner.
  \item $y1$ - The Y-coordinate of one corner.
  \item $x2$ - The opposite X-coordinate.
  \item $y2$ - The opposite Y-coordinate.
  \item $rad$ - The radius of the corner curves.
  \item $color$ - The color for the rectangle.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawLine(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                   y2 : uint16; color : R5G6B5_color);
\end{lstlisting}
\indexfunc{drawLine}
Draw a line between two points.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of one end of the line.
  \item $y1$ - The Y-coordinate of one end of the line.
  \item $x2$ - The X-coordinate of the other end of the line.
  \item $y2$ - The Y-coordinate of the other end of the line.
  \item $color$ - The color for the line.
\end{itemize}

\begin{lstlisting}
procedure drawCircle(self : RA8875_record; x : uint16; y : uint16; rad : uint16;
                     color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawCircle}
Draw a circle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $rad$ - The radius of the circle.
  \item $color$ - The color for the circle.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawTriangle(self : RA8875_record; x1 : uint16; y1 : uint16;
                       x2 : uint16; y2 : uint16; x3 : uint16; y3 : uint16;
                       color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawTriangle}
Draw a triangle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x1$ - The X-coordinate of the first point.
  \item $y1$ - The Y-coordinate of the first point.
  \item $x2$ - The X-coordinate of the second point.
  \item $y2$ - The Y-coordinate of the second point.
  \item $x3$ - The X-coordinate of the third point.
  \item $y3$ - The Y-coordinate of the third point.
  \item $color$ - The color for the triangle.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawEllipse(self : RA8875_record; x : uint16; y : uint16; hRad : uint16;
                     vRad : uint16; color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawEllipse}
Draw an ellipse oriented either horizontally or vertically.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $hRad$ - The radius in the horizontal direction.
  \item $vRad$ - The radius in the vertical direction.
  \item $color$ - The color for the ellipse.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure drawEllipseSegment(self : RA8875_record; x : uint16; y : uint16;
                             hRad : uint16; vRad : uint16; seg : RA8875_ELLIPSE_PART;
                             color : R5G6B5_color; fill : boolean);
\end{lstlisting}
\indexfunc{drawEllipseSegment}
Draw a segment of an ellipse oriented either horizontally or vertically.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $x$ - The X-coordinate of the center of the circle.
  \item $y$ - The Y-coordinate of the center of the circle.
  \item $hRad$ - The radius in the horizontal direction.
  \item $vRad$ - The radius in the vertical direction.
  \item $seg$ - Which segment to draw.
  \item $color$ - The color for the ellipse segment.
  \item $fill$ - \constant{True} for fill, \constant{False} for outline.
\end{itemize}

\begin{lstlisting}
procedure waitPoll(self : RA8875_record; reg : uint8; flag : uint8);
\end{lstlisting}
\indexfunc{waitPoll}
Repeatedly reads a register and checks for a bit to be cleared.  This is commonly used at the end of drawing routines to ensure that the drawing is complete before proceeding.  This is intended primarily for use by other of the RA8875 routines and not by user code.
\begin{itemize}
  \item $self$ - The RA8875 device to check.
  \item $reg$ - The register to check.
  \item $flag$ - The set of bits to check.  This value is \keyword{AND}ed with the register value and execution proceeds if the result is zero.
\end{itemize}

\subsubsection{Touch Methods}
\begin{lstlisting}
procedure enableTouch(self : RA8875_record; state : boolean);
\end{lstlisting}
\indexfunc{enableTouch}
Enable or disable touch processing.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $state$ - \constant{True} to enable touch, \constant{False} to disable it.
\end{itemize}

\begin{lstlisting}
function checkTouched(self : RA8875_record) return boolean;
\end{lstlisting}
\indexfunc{checkTouched}
Checks if the RA8875 has recorded a touch event.
\begin{itemize}
  \item $self$ - The RA8875 device to check.
  \item Returns \constant{True} if a touch event has occured.
\end{itemize}

\begin{lstlisting}
procedure readTouchRaw(self : RA8875_record; x : out uint16; y : out uint16);
\end{lstlisting}
\indexfunc{readTouchRaw}
Reads the raw touch location.
\begin{itemize}
  \item $self$ - The RA8875 device to read.
  \item $x$ - The raw X-coordinate of the touch location
  \item $y$ - The raw Y-coordinate of the touch location.
\end{itemize}

\begin{lstlisting}
procedure readTouchCal(self : RA8875_record; x : out uint16; y : out uint16);
\end{lstlisting}
\indexfunc{readTouchCal}
Reads the calibrated touch location.  Note that the calibration assumes a linear response.
\begin{itemize}
  \item $self$ - The RA8875 device to read.
  \item $x$ - The calibrated X-coordinate of the touch location
  \item $y$ - The calibrated Y-coordinate of the touch location.
\end{itemize}

\begin{lstlisting}
procedure touchCalibrate(self : in out RA8875_record);
\end{lstlisting}
\indexfunc{touchCalibrate}
Run a touch calibration process.  This requires the user to touch the top, bottom, left, and right edges of the touch screen.  Based on this, the limits of the touch sensor are computed and added to the RA8875 object.
\begin{itemize}
  \item $self$ - The RA8875 device to calibrate.
\end{itemize}

\begin{lstlisting}
procedure setTouchCalibration(self : in out RA8875_record; top : uint16;
                              bottom : uint16; left : uint16; right : uint16);
\end{lstlisting}
\indexfunc{setTouchCalibration}
Set the touch sensor limits for the RA8875.  This can be useful if the limits are already known and avoids running through the touch calibration process.
\begin{itemize}
  \item $self$ - The RA8875 device to calibrate.
  \item $top$ - The screen top limit.
  \item $bottom$ - The screen bottom limit.
  \item $left$ - The screen left limit.
  \item $right$ - The screen right limit.
\end{itemize}

\begin{lstlisting}
procedure getTouchCalibration(self : RA8875_record; top : out uint16;
                              bottom : out uint16; left : out uint16;
                              right : out uint16);
\end{lstlisting}
\indexfunc{getTouchCalibration}
Read the touch sensor limits from the RA8875.  This can be useful to save the limits for use with \function{setTouchCalibration}.
\begin{itemize}
  \item $self$ - The RA8875 device to read.
  \item $top$ - The screen top limit.
  \item $bottom$ - The screen bottom limit.
  \item $left$ - The screen left limit.
  \item $right$ - The screen right limit.
\end{itemize}

\subsubsection{Region and Layer Methods}
\begin{lstlisting}
procedure scroll(self : RA8875_record; hStart : uint16; vStart : uint16;
                 hEnd : uint16; vEnd : uint16; hOffset : uint16; vOffset : uint16);
\end{lstlisting}
\indexfunc{scroll}
Scroll a region on the display
\begin{itemize}
  \item $self$ - The RA8875 device to scroll.
  \item $hStart$ - The region starting horizontal coordinate.
  \item $vStart$ - The region starting vertical coordinate.
  \item $hEnd$ - The region ending horizontal coordinate.
  \item $vEnd$ - The region ending vertical coordinate.
  \item $hOffset$ - The horizontal scroll amount.
  \item $vOffset$ - The vertical scroll amount.
\end{itemize}

\begin{lstlisting}
procedure setActiveWindow(self : RA8875_record; top : uint16; bottom : uint16;
                          left : uint16; right : uint16);
\end{lstlisting}
\indexfunc{setActiveWindow}
Sets the current active window on the display.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $top$ - The top of the new active window.
  \item $bottom$ - The bottom of the new active window.
  \item $left$ - The left side of the new active window.
  \item $right$ - The right side of the new active window.
\end{itemize}

\begin{lstlisting}
procedure screenActive(self : RA8875_record);
\end{lstlisting}
\indexfunc{screenActive}
Sets the entire display area to be the active window.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
\end{itemize}

\begin{lstlisting}
procedure setLayers(self : RA8875_record; layer : RA8875_LAYER);
\end{lstlisting}
\indexfunc{setLayers}
Sets the number of layers available for use.  May be one or two.  If two layers are selected, the graphics depths is reduced to allow two layers.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $layer$ - \constant{LAYER1} for one layer, \constant{LAYER2} for two layers.
\end{itemize}

\begin{lstlisting}
procedure selectLayer(self : RA8875_record; layer : RA8875_LAYER);
\end{lstlisting}
\indexfunc{selectLayer}
Selects which layer to use.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $layer$ - The currently active layer.
\end{itemize}

\begin{lstlisting}
procedure setLayerSetting0(self : RA8875_record;
                           scroll : RA8875_LTPR0_SCROLL_MODE;
                           float : boolean; display : RA8875_LTPR0_DISP_MODE);
\end{lstlisting}
\indexfunc{setLayerSetting0}
Sets layer transparency register 0 in the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $scroll$ - Sets the scrolling mode.
  \item $float$ - Enables or disables floating window transparency display.
  \item $display$ - Sets the display mode for mixing layers 1 and 2.
\end{itemize}

\subsubsection{Cursor Methods}
\begin{lstlisting}
procedure setTextCursorPos(self : RA8875_record; x : uint16; y : uint16);
\end{lstlisting}
\indexfunc{setTextCursorPos}
Sets the text cursor position.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $x$ - The X-coordinate of the cursor.
  \item $y$ - The Y-coordinate of the cursor.
\end{itemize}

\begin{lstlisting}
procedure setGraphCursorColors(self : RA8875_record; color0 : R3G3B2_color;
                               color1 : R3G3B2_color);
\end{lstlisting}
\indexfunc{setGraphCursorColors}
Set the graphics cursor colors.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $color0$ - The first color to use.
  \item $color1$ - The second color to use.
\end{itemize}

\begin{lstlisting}
procedure setGraphCursorPos(self : RA8875_record; x : uint16; y : uint16);
\end{lstlisting}
\indexfunc{setGraphCursorPos}
Sets the graphics cursor position.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $x$ - The X-coordinate of the cursor.
  \item $y$ - The Y-coordinate of the cursor.
\end{itemize}

\begin{lstlisting}
procedure setGraphCursor(self : RA8875_record; curs : RA8875_MWCR1_GCURS_SET;
                         data : RA8875_GCursor);
\end{lstlisting}
\indexfunc{setGraphCursor}
Sets the graphics cursor.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $curs$ - The graphics cursor set.
  \item $data$ - The bitmap for the graphics cursor.
\end{itemize}

\begin{lstlisting}
procedure selectGraphCursor(self : RA8875_record; curs : RA8875_MWCR1_GCURS_SET;
                            enable : RA8875_MWCR1_GCURS_ENABLE);
\end{lstlisting}
\indexfunc{selectGraphCursor}
Selects the graphics cursor.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $curs$ - The graphics cursor set.
  \item $enable$ - Enables or disables the graphics cursor.
\end{itemize}

\subsubsection{Miscellaneous Methods}
\begin{lstlisting}
procedure fillScreen(self : RA8875_record; color : R5G6B5_color);
\end{lstlisting}
\indexfunc{fillScreen}
Fills the display with a solid color.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $color$ - The color to use.
\end{itemize}

%========================================================
\chapter{Linux API Description}
Linux defines some common methods for interfacing with devices.  This is typically using device files.  However, each platform may have different devices.  So, the Linux API description describes the implemented common API.  Then there is a discussion of Raspberry PI specific and BeagleBone Black specific items.  Since the differences are manly in which device files to use, it should be fairly easy to add new boards.

%--------------------------------------------------------------------------------------------------
\section{Common}
This section describes the implementation differences between the base common software and the Linux implementation.

\subsection{\package{BBS.embed.AIN.linux}}
As the analog inputs are handled using device files, the name of the device file has to be passed to a configure routine which then opens the file.  When finished, the file should be closed.

\begin{lstlisting}
procedure configure(self : in out Linux_AIN_record;
                    port : string);
\end{lstlisting}
\indexfunc{configure}
Configures a Linux analog input.  This needs to be done before the analog input can be used.
\begin{itemize}
  \item $self$ - The analog input to configure.
  \item $port$ - The name of the device file for the analog input.
\end{itemize}

\begin{lstlisting}
procedure close(self : in out Linux_AIN_record);
\end{lstlisting}
\indexfunc{close}
Closes a Linux analog input device file.  This should be done when the software is finished with the device.
\begin{itemize}
  \item $self$ - The analog input to close.
\end{itemize}

\subsection{\package{BBS.embed.GPIO.Linux}}
As the general-purpose I/O pins are handled using device files (sometimes multiple files), the name of the device file has to be passed to a configure routine which then opens the file.  When finished, the file should be closed.

\begin{lstlisting}
procedure configure(self : in out Linux_GPIO_record;
                    pin : string; port : string; dir : direction);
\end{lstlisting}
\indexfunc{configure}
In some cases, pins may have multiple uses.  In these cases, a pin control file needs to be accessed to select the use for the pin.
\begin{itemize}
  \item $self$ - The GPIO device to configure.
  \item $pin$ - The path to the pin control file for this GPIO.
  \item $port$ - This is a path to a directory containing various GPIO control files.
  \item $dir$ - The direction (input or output) for the GPIO pin.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out Linux_GPIO_record;
                    port : string; dir : direction);
\end{lstlisting}
\indexfunc{configure}
For dedicated pins without pin control files, a simpler form can be used for configuration.
\begin{itemize}
  \item $self$ - The GPIO device to configure.
  \item $port$ - This is a path to a directory containing various GPIO control files.
  \item $dir$ - The direction (input or output) for the GPIO pin.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : in out Linux_GPIO_record;
                  port : String; dir : direction);
\end{lstlisting}
\indexfunc{set\_dir}
Sets the direction of a pin.  This is used by the \function{configure} procedure, but can be used whenever a GPIO pin needs to change between input and output.
\begin{itemize}
  \item $self$ - The GPIO device to configure.
  \item $dir$ - The direction (input or output) for the GPIO pin.
\end{itemize}

\begin{lstlisting}
procedure close(self : in out Linux_GPIO_record);
\end{lstlisting}
\indexfunc{close}
Closes a GPIO device file.  This should be done when the software is finished with the device.
\begin{itemize}
  \item $self$ - The GPIO device to close.
\end{itemize}

\subsection{\package{BBS.embed.i2c.linux}}
This package basically provides an Ada wrapper around a bunch of C \function{ioctl} calls.
\begin{lstlisting}
procedure configure(self : in out linux_i2c_interface_record; i2c_file : string;
                    SCL : string; SDA : string);
\end{lstlisting}
\indexfunc{configure}
Configure the I2C interface on a BeagleBone Black or other systems that have multiple functions on the I2C pins.  This configuration procedure sets the pins to the I2C function.
\begin{itemize}
  \item $self$ - The I2C device to configure.
  \item $i2c\_file$ - The path to the I2C device file.  This is opened as a C file.
  \item $SCL$ - The path to the pin control file for the SCL pin for the I2C bus.
  \item $SDA$ - The path to the pin control file for the SDA pin for the I2C bus.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out linux_i2c_interface_record; i2c_file : string);
\indexfunc{configure}
\end{lstlisting}
Configure the I2C interface on a Raspberry PI or other systems that have dedicated pins for the I2C interface.  This would also work on a system with shared pins if the pins had already been set to the I2C function.
\begin{itemize}
  \item $self$ - The I2C device to configure.
  \item $i2c\_file$ - The path to the I2C device file.  This is opened as a C file.
\end{itemize}

\begin{lstlisting}
procedure close(self : in out linux_i2c_interface_record);
\end{lstlisting}
\indexfunc{close}
Closes a I2C device file.  This should be done when the software is finished with the device.
\begin{itemize}
  \item $self$ - The I2C device to close.
\end{itemize}

\subsection{\package{BBS.embed.log.linux}}
The Linux log implementation just prints the log messages to the console using \function{Ada.Text\_IO.Put} and \function{Ada.Text\_IO.Put\_Line}.  No new functions are added to the class.

\subsection{\package{BBS.embed.SPI.Linux}}
This is mostly Ada wrappers around some C I/O calls.

\begin{lstlisting}
procedure configure(self : in out Linux_SPI_record; SPI_file : string;
                    SCL : string; SDA : string);
\end{lstlisting}
\indexfunc{configure}
Configure the SPI interface on a BeagleBone Black or other systems that have multiple functions on the SPI pins.  This configuration procedure sets the pins to the SPI function.

\comment{This function is not yet implemented.  Do not attempt to use.}
\begin{lstlisting}
procedure configure(self : in out Linux_SPI_record; SPI_file : string);
\end{lstlisting}
\indexfunc{configure}
Configure the SPI interface on a Raspberry PI or other systems that have dedicated pins for the SPI interface.  This would also work on a system with shared pins if the pins had already been set to the SPI function.
\begin{itemize}
  \item $self$ - The SPI device to configure.
  \item $SPI\_file$ - The path to the SPI device file.  This is opened as a C file.
\end{itemize}

\begin{lstlisting}
procedure close(self : in out Linux_SPI_record);
\end{lstlisting}
\indexfunc{close}
Closes a SPI device file.  This should be done when the software is finished with the device.
\begin{itemize}
  \item $self$ - The SPI device to close.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{Raspberry Pi}
This section covers items specific to the Raspberry Pi.

\subsection{Initialization Script}
This initialization script needs to be run after the Raspberry Pi is booted and before attempting to run software using this package.  It contains shell commands to activate the GPIO pins and set the protection on the pin control files so that non-root users can write to them.  It also sets the protection on the I2C device file for non-root access.  The script is called \filename{init-bbb.sh} and is in the project root directory.  It needs to be run as root (typically using the \cli{sudo} command).

\subsection{\package{BBS.embed.RPI}}
This package contains string constants for the available GPIO pins, I2C device, and SPI device.  These constants should be used rather that using string literals for the path names.
%--------------------------------------------------------------------------------------------------
\section{BeagleBone Black}
This section covers items specific to the BeagleBone Black.  Note that the BeagleBone Black has more I/O options than the Raspberry Pi.  This includes PWM outputs, analog inputs, and four on-board LEDs.

\subsection{Initialization Script}
This initialization script needs to be run after the BeagleBone Black is booted and before attempting to run software using this package.  It contains shell commands to activate the various I/O options and set the protection on the pin control files and device files so that non-root users can write to them.  The script is called \filename{init-rpi.sh} and is in the project root directory.  It needs to be run as root (typically using the \cli{sudo} command).  Read through the script if you are interested in more details about what it does.  It also seems that the PWM devices get renumbered on boot.  This script does some wildcard matches and creates hard links to the appropriate device files.

\subsection{\package{BBS.embed.BBB}}
This package contains string constants for the available I/O device files.  These constants should be used rather than using string literals for the path names.  They are more extensive than the Raspberry Pi's I/O.  The comments in this package may give some insight into the I/O devices.

\subsection{\package{BBS.embed.LED}}
This package is for controlling the BeagleBone Black's four on-board LEDs.  This will probably always be unique to the BeagleBone Black.  This package hasn't changed much since the initial development.
\begin{lstlisting}
subtype led_num is Integer range 0 .. 3;
\end{lstlisting}
\indextype{led\_num}
Since there are four LEDs, the datatype \datatype{led\_num} is defined to identify them.

\begin{lstlisting}
type led_state is (off, on);
\end{lstlisting}
\indextype{led\_state}
The datatype \datatype{led\_state} is used to turn LEDs on or off.

\begin{lstlisting}
type led_states is array (led_num) of led_state;
\end{lstlisting}
\indextype{led\_states}
The datatype \datatype{led\_states} combines a state for all of the LEDs into a single array.

\begin{lstlisting}
procedure open(l : in led_num);
\end{lstlisting}
\indexfunc{open}
Open a specific LED device file.  This needs to be done before the LED can be used.
\begin{itemize}
  \item $l$ - The LED to open.
\end{itemize}

\begin{lstlisting}
procedure open;
\end{lstlisting}
\indexfunc{open}
Open all of the LED device files.  This makes all LEDs ready to be used.

\begin{lstlisting}
procedure set(l : in led_num; s : in led_state);
\end{lstlisting}
\indexfunc{set}
Sets the state of a specific LED.
\begin{itemize}
  \item $l$ - The LED to change.
  \item $s$ - The state for the LED.
\end{itemize}

\begin{lstlisting}
procedure set(led0 : in led_state; led1 : in led_state;
              led2 : in led_state; led3 : in led_state);
\end{lstlisting}
\indexfunc{set}
Sets the state of all LEDs by individually specifying the state.
\begin{itemize}
  \item $led0$ - The state for LED 0.
  \item $led1$ - The state for LED 1.
  \item $led2$ - The state for LED 2.
  \item $led3$ - The state for LED 3.
\end{itemize}

\begin{lstlisting}
procedure set(leds : in led_states);
\end{lstlisting}
\indexfunc{set}
Set the state of all LEDs by providing a \datatype{led\_states} array.
\begin{itemize}
  \item $leds$ - The array containing states for all LEDs.
\end{itemize}

\begin{lstlisting}
procedure close(l : in led_num);
\indexfunc{close}
\end{lstlisting}
Close a specific LED device file.
\begin{itemize}
  \item $l$ - The LED to close.
\end{itemize}

\begin{lstlisting}
procedure close;
\indexfunc{close}
\end{lstlisting}
Close all of the LED device files.

\subsection{\package{BBS.embed.PWM}}
This package is for controlling the BeagleBone Black's PWM outputs.

\begin{lstlisting}
type nanoseconds is range 0 .. integer'Last;
\end{lstlisting}
\indextype{nanoseconds}
The Linux PWM driver uses period and duty-cycle (actually time high) expressed  in nanoseconds.  By the time that this is translated to the device, the  actual resolution may be something different.  It is also not clear what  the maximum value of period may be.  The maximum value may also depend on  the specific PWM device being accessed.  Some experimentation would be in  order to determine what works for your application.

\begin{lstlisting}
procedure configure(self : not null access PWM_record'class;
                    pin : string; index : pwm_range);
\end{lstlisting}
\indexfunc{configure}
Configure a PWM device.  The pin control file and the PWM number must correspond, otherwise things will not work correctly.  Pin should be one of the pin constants.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $pin$ - The path to the pin control file for the PWM.
  \item $index$ - The PWM number.
\end{itemize}

\begin{lstlisting}
procedure enable(self : not null access PWM_record'class; state : boolean);
\end{lstlisting}
\indexfunc{enable}
Enables or disables a PWN device.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $state$ - \constant{True} to enable, \constant{False} to disable.
\end{itemize}

\begin{lstlisting}
procedure set_period(self : not null access PWM_record'class; period : nanoseconds);
\end{lstlisting}
\indexfunc{set\_period}
Set the period of the PWM.  This is the value used by Linux in nS.  Must be zero or positive.  Some of the PWM devices may have additional restrictions on the range.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $period$ - The time in nS between pulses on the PWM given as \datatype{nanoseconds}.
\end{itemize}

\begin{lstlisting}
procedure set_period(self : not null access PWM_record'class; period : Duration);
\end{lstlisting}
\indexfunc{set\_period}
Set the period of the PWM.  This is the value used by Linux in nS.  Must be zero or positive.  Some of the PWM devices may have additional restrictions on the range.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $period$ - The time in nS between pulses on the PWM given as \datatype{Duration}.
\end{itemize}

\begin{lstlisting}
procedure set_high(self : not null access PWM_record'class; high : nanoseconds);
\end{lstlisting}
\indexfunc{set\_high}
Set the time that the output is in the high state.  This must be between zero and the period.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $high$ - The time the output is in the high state in nS given as \datatype{nanoseconds}.
\end{itemize}

\begin{lstlisting}
procedure set_high(self : not null access PWM_record'class; high : Duration);
\end{lstlisting}
\indexfunc{set\_high}
Set the time that the output is in the high state.  This must be between zero and the period.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $high$ - The time the output is in the high state in nS given as \datatype{Duration}.
\end{itemize}

\begin{lstlisting}
procedure set_rate(self : not null access PWM_record'class; rate : BBS.units.freq_hz);
\end{lstlisting}
\indexfunc{set\_rate}
Sets the rate in Hz.  This is essentially the inverse of \function{set\_period}.  The rate is given as a floating point number and is converted to an integer number of nanoseconds.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $rate$ - The frequency of the PWM.
\end{itemize}

\begin{lstlisting}
procedure set_duty(self : not null access PWM_record'class; duty : float)
     with pre => (duty >= 0.0) and (duty <= 100.0);
\end{lstlisting}
\indexfunc{set\_duty}
Sets the duty cycle.  The duty cycle is a percentage of the period that the output is high.  The input is a floating point number and is converted to the appropriate number of nanoseconds.
\begin{itemize}
  \item $self$ - The PWM object to configure.
  \item $duty$ - The duty cycle of the PWM in percent (this must be between 0.0 and 100.0 inclusive).
\end{itemize}

%========================================================
\chapter{Arduino Due API Description}
The Arduino Due is based on the Atmel SAM3X8E ARM Cortex-M3 CPU\cite{SAM3X}.  This has not been worked on lately due to other projects (one day, I hope to get back to it) and should be considered to be experimental, but may be of some use to others working with an Arduino Due.  The packages listed here may depend on some \package{sam3x8e.*} packages.  The \package{sam3x8e.*} are autogenerated from the \filename{ATSAM3X8E.svd} file and they provide many of the low-level constants and datatypes for access the SAM3X hardware.

The following sections describe device specific additions or alterations to the common classes as well as unique device specific routines.

\section{\package{BBS.embed.AIN.due}}
This section describes the Arduino Due implementation of analog inputs.

Note that enabling an analog input will supersede any other use for that pin.  The architecture has defined 16 analog inputs, 0-15, with input 15 being used to measure the CPU temperature.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    SAM3X8E Input & Arduino Due Pin \\
    \hline
    AD0 & AD07. \\
    AD1/WKUP1 & AD06. \\
    AD2 & AD05. \\
    AD3 & AD04. \\
    AD4 & AD03. \\
    AD5 & AD02. \\
    AD6 & AD01. \\
    AD7 & AD00. \\
    AD8 & Unused \\
    AD9 & Unused \\
    AD10 & AD08. \\
    AD11 & AD09. \\
    AD12 & AD10. \\
    AD13 & AD11/TXD3. \\
    AD14 & Unused \\
    AD15 & CPU temp sensor. \\
  \end{tabular}
  \caption{SAM3X8E Analog Input Assignment to Arduino Due Pins}
  \label{tbl:ArduinoDueAIN}
\end{center}
\end{table}

Do not use channels marked as unused.  It may cause problems.  Using AD15, the CPU temperature sensor also seems to cause trouble with tasking.

\begin{lstlisting}
subtype AIN_Num is Integer range 0 .. 11;
\end{lstlisting}
\indextype{AIN\_Num}
Define a subtype for the Arduino analogs inputs.  These are mapped to the analog channels via an array defined in the private section of this package.  Using this prevents the unused channels from being accessed.

\begin{lstlisting}
procedure enable_ain(self : Due_AIN_record; b : Boolean);
\end{lstlisting}
\indexfunc{enable\_ain}
Enable or disable a specified analog input object.
\begin{itemize}
  \item $self$ - The analog input device to configure.
  \item $b$ - \constant{True} to enable, \constant{False} to disable.
\end{itemize}

\begin{lstlisting}
procedure setup_ain;
\end{lstlisting}
\indexfunc{setup\_ain}
Setup the analog to digital controller.  This needs to be done before using the analog input.

\begin{lstlisting}
procedure enable_ain(c : AIN_Num; b : Boolean);
\end{lstlisting}
\indexfunc{enable\_ain}
Enable or disable a specified analog input channel.  Generally, the object oriented call should be used instead.
\begin{itemize}
  \item $c$ - The Arduino analog input number to configure.
  \item $b$ - \constant{True} to enable, \constant{False} to disable.
\end{itemize}

\begin{lstlisting}
procedure start;
\end{lstlisting}
\indexfunc{start}
Start an analog to digital conversion.

\begin{lstlisting}
procedure free_run(b : Boolean);
\end{lstlisting}
\indexfunc{free\_run}
Set free running conversion.
\begin{itemize}
  \item $b$ - \constant{True} to enable free running conversion, \constant{False} to disable it.
\end{itemize}

\begin{lstlisting}
function get(c : AIN_Num) return UInt12;
\end{lstlisting}
\indexfunc{get}
Read an ADC value from a channel.  Generally, the object oriented call should be used instead.
\begin{itemize}
  \item $c$ - The Arduino analog input number
  \item Returns the 12-bit converted value.
\end{itemize}

\section{\package{BBS.embed.due.dev}}
This package contains a set of constants for the device numbers for the SAM3X devices.  It was collected here as it wasn't really available anywhere else.  This is primarily for internal use only.

\section{\package{BBS.embed.Due.GPIO}}
This package contains a collection of pin objects for the Arduino Pins.  If memory is tight for your application, just copy out the ones that you need.  There does not seem to be much rhyme or reason for how the CPU pins are assigned to the Arduino pins.

\section{\package{BBS.embed.due.serial}}
This package is the root of the serial I/O functionality on the Arduino Due.  It has four of its serial ports wired to the headers.  These ports are numbered 0 through 3.  Port 0 is also wired to the programming USB connector and is used as the default port, if none is specified.

Communication is available in both polled and interrupt driven variants.  Polled is unbuffered and has very little memory overhead, but puts more load on the CPU.  It is most useful when memory is tight or serial I/O needs are minimal.  It would also be useful as a method of last resort for printing messages from an exception handler.

Interrupt driven copies messages into a buffer and uses an interrupt handler to feed characters into the UART as needed.  The main thread of software can continue processing while this is happening.  This provides more processing for user software at the expense of requiring memory for the buffers.

This package contains definitions and code that is common to both methods. The interrupt or polled specific definitions and code are in the appropriate sub-package.

\begin{lstlisting}
type port_id is new Integer range 0 .. 3;
\end{lstlisting}
\indextype{port\_id}
This type is used to identify which of the four available serial ports is being used.

\begin{lstlisting}
procedure init(baud_rate : SAM3x8e.UInt32);
\end{lstlisting}
\indexfunc{init}
Initialize the serial port attached to the programming USB port.  It looks like this is equivalent to channel zero.
\begin{itemize}
  \item $baud\_rate$ - The desired baud rate for the USB programming port.
\end{itemize}

\begin{lstlisting}
procedure init(chan_num : port_id; baud_rate : SAM3x8e.UInt32);
\end{lstlisting}
\indexfunc{init}
Initialize the serial port attached to the specified channel.
\begin{itemize}
  \item $chan\_num$ - The channel number of the port to initialize.
  \item $baud\_rate$ - The desired baud rate for the USB programming port.
\end{itemize}

\begin{lstlisting}
function tx_ready return Boolean;
\end{lstlisting}
\indexfunc{tx\_ready}
Check if the USB programming port transmitter is ready.
\begin{itemize}
  \item Returns \constant{True} if the transmitter is ready.
\end{itemize}

\begin{lstlisting}
function tx_ready(chan : port_id) return Boolean;
\end{lstlisting}
\indexfunc{tx\_ready}
Check if the specified serial port transmitter is ready.
\begin{itemize}
  \item $chan$ - The channel number of the serial port to check.
  \item Returns \constant{True} if the transmitter is ready.
\end{itemize}

\begin{lstlisting}
function rx_ready return Boolean;
\end{lstlisting}
\indexfunc{rx\_ready}
Check if the USB programming port receiver is ready.
\begin{itemize}
  \item Returns \constant{True} if the transmitter is ready.
\end{itemize}

\begin{lstlisting}
function rx_ready(chan : port_id) return Boolean;
\end{lstlisting}
\indexfunc{rx\_ready}
Check if the specified serial port receiver is ready.
\begin{itemize}
  \item $chan$ - The channel number of the serial port to check.
  \item Returns \constant{True} if the receiver is ready.
\end{itemize}

\begin{lstlisting}
function tx_empty return Boolean;
\end{lstlisting}
\indexfunc{tx\_empty}
Check if the USB programming port transmitter is empty.
\begin{itemize}
  \item Returns \constant{True} if the transmitter is empty.
\end{itemize}

\begin{lstlisting}
function tx_empty(chan : port_id) return Boolean;
\end{lstlisting}
\indexfunc{tx\_empty}
Check if the specified serial port transmitter is empty.
\begin{itemize}
  \item $chan$ - The channel number of the serial port to check.
  \item Returns \constant{True} if the transmitter is empty.
\end{itemize}

\section{\package{BBS.embed.due.serial.int}}
This is an interrupt driven serial package that can be used to print text with reduced overhead for the user code.  Characters are written to a buffer which is sent to the UART under control of interrupts.

An even more processor efficient option would be to use DMA for handling the I/O.  This is left for a future project.

There are two goals for this driver.  The first is to provide console I/O for a person to communicate with the device.  The second is to be able to communicate with other devices.  There are many features that could be added, but it should be kept fairly simple and primitive.

Many of the routines can be called with a channel number, a serial port object, or nothing (this is similar to \package{Ada.Text\_IO}).  If no channel or object is provided, the default serial port (USB programming port, or channel 0) is used.

\begin{lstlisting}
function init(c : port_id; baud : SAM3x8e.UInt32) return serial_port;
\end{lstlisting}
\indexfunc{init}
Initialize a channel and return the serial port object for that channel.
\begin{itemize}
  \item $c$ - The channel number.
  \item $baud$ - The baud rate.
  \item Returns the serial port object for the channel.
\end{itemize}

\begin{lstlisting}
function get_port(c : port_id) return serial_port;
\end{lstlisting}
\indexfunc{get\_port}
Return the serial port object for a channel.
\begin{itemize}
  \item $c$ - The channel number.
  \item Returns the serial port object for the channel.
\end{itemize}

\begin{lstlisting}
procedure put(c : Character);
procedure put(chan : port_id; c : Character);
procedure put(self : not null access serial_port_record'class; c : Character);
\end{lstlisting}
\indexfunc{put}
Send a character to a serial port.  There are three options.  The default with no port or channel identifier sends the character to port 0 (the USB programming port).
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $c$ - The character to send.
\end{itemize}

\begin{lstlisting}
procedure put(s : string);
procedure put(chan : port_id; s : string);
procedure put(self : not null access serial_port_record'class; s : String);
\end{lstlisting}
\indexfunc{put}
Send a string to a serial port.  There are three options.  The default with no port or channel identifier sends the character to port 0 (the USB programming port).
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $s$ - The string to send.
\end{itemize}

\begin{lstlisting}
procedure put_line(s : string);
procedure put_line(chan : port_id; s : string);
procedure put_line(self : not null access serial_port_record'class; s : String);
\end{lstlisting}
\indexfunc{put\_line}
Send a string to a serial port, followed by a CR/LF combination.  There are three options.  The default with no port or channel identifier sends the character to port 0 (the USB programming port).
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $s$ - The string to send.
\end{itemize}

\begin{lstlisting}
procedure new_line;
procedure new_line(chan : port_id);
procedure new_line(self : not null access serial_port_record'class);
\end{lstlisting}
\indexfunc{new\_line}
Send a CR/LF combination to a serial port for a new line.  There are three options.  The default with no port or channel identifier sends the character to port 0 (the USB programming port).
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
\end{itemize}

\begin{lstlisting}
procedure enable_rs485(chan : port_id; d : BBS.embed.GPIO.Due.Due_GPIO_ptr)
  with pre => ((d.ctrl = BBS.embed.GPIO.Due.PIOA'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOB'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOC'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOD'Access));
procedure enable_rs485(self : not null access serial_port_record'class;
                       d : BBS.embed.GPIO.Due.Due_GPIO_ptr)
  with pre => ((d.ctrl = BBS.embed.GPIO.Due.PIOA'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOB'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOC'Access) or
                   (d.ctrl = BBS.embed.GPIO.Due.PIOD'Access));
\end{lstlisting}
\indexfunc{enable\_rs485}
Enables RS-485 mode on an I/O channel.  It requires an initialized digital I/O pin record.  If d.ctrl isn't pointing to a PIO control record, bad things can happen, so make this a precondition.  This hasn't really been tested.  Use with caution
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $d$ - The GPIO pin record to use as a RS-485 control pin.
\end{itemize}

\begin{lstlisting}
procedure flush(chan : port_id);
procedure flush(self : not null access serial_port_record'class);
\end{lstlisting}
\indexfunc{flush}
Wait until transmit buffer is empty.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
\end{itemize}

\begin{lstlisting}
procedure rx_enable(chan : port_id; b : Boolean);
procedure rx_enable(self : not null access serial_port_record'class; b : Boolean);
\end{lstlisting}
\indexfunc{rx\_enable}
Enable or disable the RX interrupt.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $b$ - \constant{True} to enable, \constant{False} to disable.
\end{itemize}

\begin{lstlisting}
function rx_ready return Boolean;
function rx_ready(chan : port_id) return Boolean;
function rx_ready(self : not null access serial_port_record'class)
   return Boolean;
\end{lstlisting}
\indexfunc{rx\_ready}
Check to see if characters are available in the buffer
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item Returns \constant{True} if characters are available in the buffer.
\end{itemize}

\begin{lstlisting}
function get return Character;
function get(chan : port_id) return Character;
function get(self : not null access serial_port_record'class)
   return Character;
\end{lstlisting}
\indexfunc{get}
Read a character from the buffer.  If no character is available, wait until one is and then read it.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item Returns the next character from the buffer.
\end{itemize}

\begin{lstlisting}
function peek return Character;
function peek(chan : port_id) return Character;
function peek(self : not null access serial_port_record'class)
   return Character;
\end{lstlisting}
\indexfunc{peek}
Return the next character in the receive buffer without removing it.  If no character is available, wait until one is and then read it.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item Returns the next character from the buffer.
\end{itemize}

\begin{lstlisting}
procedure get_line(s : out String; l : out Natural);
procedure get_line(chan : port_id; s : in out String; l : out Natural);
procedure get_line(self : not null access serial_port_record'class;
                      s : in out String; l : out Natural);
\end{lstlisting}
\indexfunc{get\_line}
Return a line of text, waiting as needed until a line is complete.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item Returns the next line of text from the buffer.
\end{itemize}

\begin{lstlisting}
procedure set_echo(chan : port_id; b : Boolean);
procedure set_echo(self : not null access serial_port_record'class; b : Boolean);
\end{lstlisting}
\indexfunc{set\_echo}
Enables or disables echo of received characters.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $b$ - \constant{True} to enable echoing of characters.
\end{itemize}

\begin{lstlisting}
procedure set_del(chan : port_id; b : Boolean);
procedure set_del(self : not null access serial_port_record'class; b : Boolean);
\end{lstlisting}
\indexfunc{set\_del}
Enables or disables deleting of received characters.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $self$ - The serial port object to use.
  \item $b$ - \constant{True} to enable deleting of characters.
\end{itemize}

\section{\package{BBS.embed.due.serial.polled}}
This is a very simple serial package that can be used to print some debugging information.  It uses polling to wait for each character to be passed to the UART.  This makes it not particularly efficient. However, it will work even if the interrupts get all screwed up, which makes it useful in a last resort exception handler to get a message printed.

\begin{lstlisting}
procedure put(c : Character);
procedure put(chan : port_id; c : Character);
\end{lstlisting}
\indexfunc{put}
Write a character to a serial port.  It does a busy wait on the \package{UART\_SR} \package{TXRDY} (transmit ready) bit.  It does a loop until the value of the bit is 1 and then write the character.  If no channel is specified in the call, channel 0 (the USB programming port) is used.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $c$ - The character to transmit.
\end{itemize}

\begin{lstlisting}
procedure put(s : string);
procedure put(chan : port_id; s : string);
\end{lstlisting}
\indexfunc{put}
Write a string to a serial port.  If no channel is specified in the call, channel 0 (the USB programming port) is used.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $s$ - The string to transmit.
\end{itemize}

\begin{lstlisting}
procedure put_line(s : string);
procedure put_line(chan : port_id; s : string);
\end{lstlisting}
\indexfunc{put\_line}
Write a string to a serial port, followed by a CR/LF combination.  If no channel is specified in the call, channel 0 (the USB programming port) is used.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item $s$ - The string to transmit.
\end{itemize}

\begin{lstlisting}
function get return Character;
function get(chan : port_id) return Character;
\end{lstlisting}
\indexfunc{get}
Read a character from serial port - wait for one to be present, if necessary.
\begin{itemize}
  \item $chan$ - The serial port's channel number.
  \item Returns the character from the serial port.
\end{itemize}

\section{\package{BBS.embed.due}}
This is the root package for the Arduino Due specific packages.  It currently has no other contents.

\section{\package{BBS.embed.GPIO.Due}}
This is a description of the Arduino Due specific GPIO functions.  For the Arduino Due, pin records in the package \package{BBS.embed.Due.GPIO} are used to define each pin, rather than using device files like Linux based systems.

\begin{lstlisting}
type direction is (gpio_input, gpio_output, funct_a, funct_b);
\end{lstlisting}
\indextype{direction}
The datatype \datatype{direction} is used to identify the function of a pin.  As is typical, most pins have multiple possible functions.

\begin{lstlisting}
procedure config(self : in out Due_GPIO_record;
                 pin : Due_GPIO_record; dir : direction);
\end{lstlisting}
\indexfunc{config}
Configures a pin to be controlled by the PIO controller.  Output is enabled or disabled based on the value of dir.
\begin{itemize}
  \item $self$ - The GPIO record to configure.
  \item $pin$ - This should be one of the pin records from the package \package{BBS.embed.Due.GPIO}.  The data from this record are used to populate $self$.
  \item $dir$ - Indicates the function for the pin.
\end{itemize}

\begin{lstlisting}
procedure config(self : in out Due_GPIO_record; dir : direction);
\end{lstlisting}
\indexfunc{config}
Configures a pin to be controlled by the PIO controller.  Output is enabled or disabled based on the value of dir.  The values in $self$ are assumed to already be assigned.  Typically, this would be used to re-configure a pin.
\begin{itemize}
  \item $self$ - The GPIO record to configure.
  \item $dir$ - Indicates the function for the pin.
\end{itemize}

\begin{lstlisting}
procedure pullup(self : Due_GPIO_record; val : Bit);
\end{lstlisting}
\indexfunc{pullup}
Enable or disable pullup on a pin.
\begin{itemize}
  \item $self$ - The GPIO record to configure.
  \item $val$ - Set to 1 to enable pullup.  Set to 0 to disable pullup.
\end{itemize}

\section{\package{BBS.embed.i2c.due}}
This is a description of the Arduino Due specific I2C bus functions.

\begin{lstlisting}
type speed_type is (low100, high400);
\end{lstlisting}
\indextype{speed\_type}
The datatype \datatype{speed\_type} is used to select the speed of the I2C interface.

\begin{lstlisting}
type port_id is  new Integer range 0 .. 1;
\end{lstlisting}
\indextype{port\_id}
The datatype \datatype{port\_id} is used to select one of the two I2C ports on the Arduino Due.

\begin{lstlisting}
function get_interface(d : port_id) return due_i2c_interface;
\end{lstlisting}
\indexfunc{get\_interface}
The interface records are declared in the private section.  This returns an access to the record for the specified channel.
\begin{itemize}
  \item $d$ - The specified I2C channel.
  \item Returns an access to the interface record for the specified channel.
\end{itemize}

\begin{lstlisting}
procedure init(chan : port_id; speed : speed_type);
\end{lstlisting}
\indexfunc{init}
Initializes the specified I2C channel and sets the speed.
\begin{itemize}
  \item $d$ - The specified I2C channel.
  \item $speed$ - The selected speed for the channel.
\end{itemize}

\begin{lstlisting}
function get_activity(self : in out due_i2c_interface_record) return uint32;
\end{lstlisting}
\indexfunc{get\_activity}
Returns the I2C activity counter for the specified channel.  This is primarily useful for debugging to ensure that the device is actually processing transactions.
\begin{itemize}
  \item $d$ - The specified I2C channel.
  \item Returns the activity counter for the specified channel.
\end{itemize}

\begin{lstlisting}
function is_busy(self : in out due_i2c_interface_record) return Boolean;
\end{lstlisting}
\indexfunc{is\_busy}
Returns the busy status for the specified channel.
\begin{itemize}
  \item $d$ - The specified I2C channel.
  \item Returns the busy status for the specified channel.  \constant{True} for busy, \constant{False} for not busy.
\end{itemize}

\section{\package{BBS.embed.log.due}}
The Arduino Due specific logging uses the interrupt driven serial driver to sent the log messages to serial channel 0.  No Arduino Due specific routines exist.

\section{\package{BBS.embed.SPI.Due}}
This is a description of the Arduino Due specific SPI bus functions.  I don't think that this has been tested, but it might work.

\begin{lstlisting}
procedure configure(self : in out Due_SPI_record);
\end{lstlisting}
\indexfunc{configure}
Configure the SPI interface.  The SAM3X8E core actually has two SPI interfaces, but SPI1 does not seem to be present on the chip pinout.
\begin{itemize}
  \item $self$ - The SPI device record to configure.
\end{itemize}

%========================================================
\clearpage
%
%  Add indices
%
\addcontentsline{toc}{chapter}{Indices}
\printindex[type]
\printindex[func]
%
%  Add bibliography
%
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{devices.bib}

\end{document}
