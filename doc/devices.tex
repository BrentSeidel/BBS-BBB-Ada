\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage{tikz}
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\cli}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
\newcommand{\comment}[1]{{\color{red}{#1}}}
%
\newcommand{\docname}{Users's Manual for \\ Device Interfaces}
%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024, Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\listoftables

\mainmatter
%========================================================
\chapter{Introduction}

%--------------------------------------------------------------------------------------------------
\section{About the Project}
This project provides an interface to hardware available on some Linux based systems and the Arduino Due.  It consists of two main components:  First an abstract set of classes for certain generic hardware items, and second specific classes to interface with the hardware on specific devices.  This separation is done to ease porting of software between different devices.  The two Linux based devices that are currently supported are the Raspberry Pi and the BeagleBone Black.  Other devices may be added by creating a set of specific classes for the device.

%--------------------------------------------------------------------------------------------------
\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How to Obtain}

This collection is currently available on GitHub at \url{https://github.com/BrentSeidel/BBS-BBB-Ada}.  Parts are available through alire via ``\keyword{alr get bbs\_embed\_common}'' and ``\keyword{alr get bbs\_embed\_linux}''

%--------------------------------------------------------------------------------------------------
\section{Dependencies}
\subsection{bbs\_embed\_common}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Integer\_Text\_IO}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions} (used only by lsm303dlhc)
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Text\_IO}
  \item \package{Ada.Unchecked\_Conversion}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed.GPIO}
  \item \package{BBS.embed.i2c}
  \item \package{BBS.embed.log}
  \item \package{BBS.embed.SPI}
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_linux}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Direct\_IO}
  \item \package{Ada.IO\_Exceptions}
  \item \package{Ada.Long\_Integer\_Text\_IO}
  \item \package{Ada.Strings.Fixed}
  \item \package{Ada.Text\_IO}
  \item \package{Interfaces.C}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed}*
  \item \package{BBS.embed.BBB}*
  \item \package{BBS.embed.GPIO}*
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_due}
The Arduino Due requires an appropriate run-time system and cross-compiler.
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Interrupts}
  \item \package{Ada.Interrupts.Names}
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Synchronous\_Task\_Control}
  \item \package{Interfaces}
  \item \package{System}
  \item \package{System.Sam3x8}
\end{itemize}
\subsubsection{SAM3x8e Stuff}
The following SAM3x8e hardware definition packages are used:
\begin{itemize}
  \item \package{SAM3x8e}
  \item \package{SAM3x8e.ADC}
  \item \package{SAM3x8e.PIO}
  \item \package{SAM3x8e.PMC}
  \item \package{SAM3x8e.TWI}
  \item \package{SAM3x8e.UART}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS}*
  \item \package{BBS.embed}*
  \item \package{BBS.embed.due.dev}
  \item \package{BBS.embed.due.serial.int}
  \item \package{BBS.embed.due.serial.polled}
  \item \package{BBS.embed.GPIO.Due}
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
\end{itemize}


%========================================================
\chapter{Usage Instructions}
This chapter contains high-level instructions on using this library in your project.  First, all projects will need to include the \package{bbs\_embed\_common} packages to gain access to the base classes and some device drivers that build on these base classes.  The second step is platform specific, as described below.

%--------------------------------------------------------------------------------------------------
\section{Linux Based Raspberry Pi and BeagleBone Black}
You will need to include the \package{bbs\_embed\_linux} packages in your project.  The \package{BBS.embed.rpi} package contains constants for various device names available on the Raspberry Pi.  The \package{BBS.embed.BBB} package contains constants for various devices names on the BeagleBone Black.  There is a script, \package{init-bbb.sh} for the BeagleBone Black or \package{init-rpi.sh} for the Raspberry Pi that needs to be run to activate some of the devices and set protections on the device files.  The script will need to be run as superuser, using the \cli{sudo} command.  Among other things, it sets protection on the device files so that your software does not need to run as superuser.

%--------------------------------------------------------------------------------------------------
\section{Arduino Due}
This has not been worked on for a while.  To use this, you will need an ARM ELF Ada compiler and a board support package for the Arduino Due.  It did work with a board support package that I'd cobbled together a few generations of gnat ago.  Consider this to be experimental, but it should provide a good start to accessing hardware on the Arduino Due.

%========================================================
\chapter{Common API Description}
Dealing with hardware can be complex, especially if you want your software to be portable.  The various different boards have different devices (or different numbers of devices) available.  Sometimes options are available on one board that are not available on another.

The common library (\package{bbs\_embed\_common} in alire) contains base classes for hardware devices and higher-level drivers for devices that attach to the basic hardware, for example devices that connect via an I2C bus.

%--------------------------------------------------------------------------------------------------
\section{Basic Devices}
The package \package{BBS.embed} defines the following types and functions:
\begin{lstlisting}
type addr7 is mod 2**7
  with size => 7;
type int12 is range -(2**11) .. 2**11 - 1
  with size => 12;
type uint12 is mod 2**12
  with size => 12;
\end{lstlisting}
The \datatype{addr7} is used for addressing devices on an I2C bus.  the \datatype{int12} and \datatype{uint12} are used for the return values from typical analog to digital converters and anywhere else a 12 bit number is needed.
\begin{lstlisting}
function uint12_to_int12 is
  new Ada.Unchecked_Conversion(source => uint12, target => int12);
\end{lstlisting}
This is used to convert from unsigned to signed 12 bit integers.  Should the reverse conversion be needed, it would be easy enough to add it here.
\begin{lstlisting}
function highByte(x : uint16) return uint8 is
     (uint8(x / 2**8));
function lowByte(x : uint16) return uint8 is
      (uint8(x and 16#FF#));
\end{lstlisting}
These are used to extract the MSB and LST from \datatype{uint16} values.

\subsection{Analog Inputs}
Analog inputs have one common routine to read the value.  Everything else is implementation dependent.
\begin{lstlisting}
function get(self : AIN_record) return uint12 is abstract;
\end{lstlisting}
Read the value of the specified analog to digital converter.
\begin{itemize}
  \item $self$ - The object for the analog input device.
  \item Returns the 12-bit value from the analog to digital converter.
\end{itemize}

\subsection{General-Purpose Input/Output (GPIO)}
A GPIO is a device capable of reading or writing a single bit.  The physical characteristics are hardware dependent.  Some device specific routines may be needed to convert between input and output.
\begin{lstlisting}
procedure set(self : GPIO_record; value : bit) is abstract;
\end{lstlisting}
Sets the output value of a GPIO device.  The effect if the device is set to input is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item $value$ - The value to write to the GPIO device.
\end{itemize}
\begin{lstlisting}
function get(self : GPIO_record) return bit is abstract;
\end{lstlisting}
Reads the value of a GPIO device.  The value returned if the device is set to output is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item Returns the value read from the GPIO device.
\end{itemize}

\subsection{I2C Bus}
An I2C bus can interface with a number of devices on the bus.  It operates with the CPU being the master and the addressed device responding.  The basic I2C bus uses 7 bit addressing for devices and operates at 100kHz.  Any other options (10 bit addressing or higher speeds would be device specific, if supported).

The \package{BBS.embed.i2c} defines some datatypes.  The ones for external use are:
\begin{itemize}
  \item \datatype{err\_code} is an enumeration of error statuses that can be returned.  The possible values are \datatype{none}, \datatype{nack}, \datatype{ovre}, \datatype{invalid\_addr}, and \datatype{failed}.  In most cases you'll just want to compare the returned error to \datatype{none}.
  \item \datatype{buff\_index} is an \datatype{Integer} index into a buffer with a range of 0 .. 127.
  \item \datatype{buffer} is an array of \datatype{uint8} and bounds of \datatype{buff\_index}.  It is used for buffering data for I2C bus transfers.
\end{itemize}

The following routines are used for communicating with devices on the I2C bus.  Note that there is no standard about whether multibyte data should be transferred LSB first or MSB first (I've even seen devices that use both depending on which data you're getting).  Routines are provided for MSB first (m1 routines) or MSB second (m2 routines) for 16 bit transfers.  For longer transfers, use the block transfer routines and decode the data yourself.  The 8 and 16 bit routines cover most of the cases.
\begin{lstlisting}
function read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
              error : out err_code) return uint8 is (0);
\end{lstlisting}
Read a single byte of data from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred first from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred second from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
procedure read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
               size : buff_index; error : out err_code) is null;
\end{lstlisting}
Reads a block of data into the interface record's buffer.  The user's code will need to extract the data from that buffer and process it as needed.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                data : uint8; error : out err_code) is null;
\end{lstlisting}
Write a single byte of data to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred first to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred second to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                size : buff_index; error : out err_code) is null;
\end{lstlisting}
Send the specified number of bytes in the interface record's buffer to the specified device and register.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}
In most cases these routines should only be used when writing a driver for an I2C device.

\subsection{Logging}
\comment{This is only for debugging purposes.  Should say something here briefly.}

\subsection{SPI Bus}
The exposed interface for the SPI bus is much simpler than for the I2C bus.  If needed, more routines may be added here, but this hasn't been developed as much as the I2C bus interface.
\begin{lstlisting}
procedure set(self : SPI_record; value : uint8) is abstract;
\end{lstlisting}
Writes a byte to the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item $data$ - The data to write.
\end{itemize}
\begin{lstlisting}
function get(self : SPI_record) return uint8 is abstract;
\end{lstlisting}
Reads a byte from the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item Returns the byte read from the bus.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{Higher-Level Device Drivers}
These higher-level device drivers build on the lower-level devices.  Typically these are devices that attach to a databus.

\subsection{\package{BBS.embed.gpio.tb6612}}
This is a driver for the Toshiba TB6612 dual DC motor controller \cite{TB6612}.  The device driver is designed to sequence the output to drive a stepper motor, or it can control two DC motors separately.  It requires four GPIO output pins.

\begin{lstlisting}
procedure init(self : in out TB6612_record; pin_a : BBS.embed.GPIO.GPIO;
               pin_b : BBS.embed.GPIO.GPIO; pin_c : BBS.embed.GPIO.GPIO;
               pin_d : BBS.embed.GPIO.GPIO);
\end{lstlisting}
Initialize the TB6612 driver with the 4 GPIO devices.
\begin{itemize}
  \item $self$ - The TB6612 device to initialize.
  \item $pin\_a$ - The first GPIO pin.
  \item $pin\_b$ - The second GPIO pin.
  \item $pin\_c$ - The third GPIO pin.
  \item $pin\_d$ - The fourth GPIO pin.
\end{itemize}
\begin{lstlisting}
procedure set_delay(self : in out TB6612_record; wait_time : Natural);
\end{lstlisting}
Set a time delay between steps to use when stepping the motor a number of steps.  If not needed, it can be set to zero.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $wait\_time$ - The time delay between steps in mS.
\end{itemize}
\begin{lstlisting}
procedure step(self : in out TB6612_record; steps : Integer);
\end{lstlisting}
Move the stepper motor a specified number of steps.  A negative number will move in the opposite direction as a positive number.  Zero steps will do nothing.  If no delay has been specified, a default of 5mS between steps will be used.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $steps$ - The number of steps to move the motor.
\end{itemize}
\begin{lstlisting}
procedure stepper_off(self : in out TB6612_record);
\end{lstlisting}
De-energize the coils for a stepper motor (or both DC motors).
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
\end{itemize}
\begin{lstlisting}
procedure set_bridge_a(self : in out TB6612_record; value : Integer);
procedure set_bridge_b(self : in out TB6612_record; value : Integer);
\end{lstlisting}
Each of the two H-bridges can be controlled separately.  This would allow two DC motors to be driven.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $value$ - A value of zero sets the bridge off.  A positive value sets the polarity in one direction.  A negative value sets the polarity in the opposite direction.
\end{itemize}

Note that polarities are not specified as they depend on how the hardware is wired.

\subsection{\package{BBS.embed.I2C.ADS1015}}
This is a driver for the Texas Instruments ADS1015 4 channel analog to digital convertor that attaches to an I2C bus \cite{ADS1015}.  This converter has a wide variety of configuration options.  Refer to the datasheet for details.  A number of constants have been defined to support the various configuration options (see Tables \ref{tbl:ADS1015mux}, \ref{tbl:ADS1015PGA}. \ref{tbl:ADS1015DRC}, and \ref{tbl:ADS1015CompQ}).

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Mux Mode Configuration \\
    \hline
    \constant{mux\_a0\_a1} & Difference between AIN0 and AIN1 (default) \\
    \constant{mux\_a0\_a3} & Difference between AIN0 and AIN3 \\
    \constant{mux\_a1\_a3} & Difference between AIN1 and AIN3 \\
    \constant{mux\_a2\_a3} & Difference between AIN2 and AIN3 \\
    \constant{mux\_a0\_gnd} & Single ended AIN0 value \\
    \constant{mux\_a1\_gnd} & Single ended AIN1 value \\
    \constant{mux\_a2\_gnd} & Single ended AIN2 value \\
    \constant{mux\_a3\_gnd} & Single ended AIN3 value \\
  \end{tabular}
  \caption{Constants for ADS1015 Mux Mode Configuration}
  \label{tbl:ADS1015mux}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & PGA Configuration \\
    \hline
    \constant{pga\_6\_144} & Full scale voltage is 6.144V \\
    \constant{pga\_4\_096} & Full scale voltage is 4.096V \\
    \constant{pga\_2\_048} & Full scale voltage is 2.048V (default) \\
    \constant{pga\_1\_024} & Full scale voltage is 1.024V \\
    \constant{pga\_0\_512} & Full scale voltage is 0.512V \\
    \constant{pga\_0\_256} & Full scale voltage is 0.256V \\
  \end{tabular}
  \caption{Constants for ADS1015 Programmable Gain Amplifier Configuration}
  \label{tbl:ADS1015PGA}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Data Rate in Samples per Second (S/S) \\
    \hline
    \constant{dr\_0128} & Data rate is 128S/S \\
    \constant{dr\_0250} & Data rate is 250S/S \\
    \constant{dr\_0490} & Data rate is 490S/S \\
    \constant{dr\_0920} & Data rate is 920S/S \\
    \constant{dr\_1600} & Data rate is 1600S/S (default) \\
    \constant{dr\_2400} & Data rate is 2400S/S \\
    \constant{dr\_3300} & Data rate is 3300S/S \\
  \end{tabular}
  \caption{Constants for ADS1015 Data Rate Configuration}
  \label{tbl:ADS1015DRC}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Comparator Queue Configuration \\
    \hline
    \constant{comp\_que\_1} & Assert after one conversion \\
    \constant{comp\_que\_2} & Assert after two conversions \\
    \constant{comp\_que\_3} & Assert after three conversion \\
    \constant{comp\_que\_d} & Disable comparator (default) \\
  \end{tabular}
  \caption{Constants for ADS1015 Comparator Queue Configuration}
  \label{tbl:ADS1015CompQ}
\end{center}
\end{table}

There are some additional configuration parameters that don't have constants defined.  These just have values of 0 or 1.  See Table \ref{tbl:ADS1015Misc}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Value & Conversion Mode \\
    0 & Continuous conversion mode \\
    1 & Power-down single-shot mode (default) \\
    \hline
    Value & Comparator Mode \\
    0 & Traditional, with hysteresis (default) \\
    1 & Window comparator \\
    \hline
    Value & Comparator Polarity \\
    0 & Active low (default) \\
    1 & Active high \\
    \hline
    Value & Comparator Latching \\
    0 & Non-latching comparator (default) \\
    1 & Latching comparator \\
  \end{tabular}
  \caption{Constants for ADS1015 Miscellaneous Configuration}
  \label{tbl:ADS1015Misc}
\end{center}
\end{table}

The datatype \datatype{ADS1015\_config} is defined as a record containing the configuration values.  It has the following fields:
\begin{itemize}
    \item \datatype{os} - Operational status, used to start a conversion if in single shot mode.  Don't use when setting configuration.
    \item \datatype{mux} - The mux mode (see Table \ref{tbl:ADS1015mux}).
    \item \datatype{pga} - The programmable gain type (see Table \ref{tbl:ADS1015PGA}).
    \item \datatype{mode} - Conversion mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{dr} - The data rate (see Table \ref{tbl:ADS1015DRC}).
    \item \datatype{comp\_mode} - The comparator mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_pol} - The comparator polarity (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_lat} - The comparator latching (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_que} - The comparator queue configuration  (see Table \ref{tbl:ADS1015CompQ}).
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Initializes the device to the default configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; config : ADS1015_config; error : out err_code);
\end{lstlisting}
Initialize the device using the specified configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure change_config(self : in out ADS1015_record;
                        config : ADS1015_config; error : out err_code);
\end{lstlisting}
Changes the device configuration to new values
\begin{itemize}
  \item $self$ - The device to modify.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_mux(self : in out ADS1015_record;
                  mux : mux_mode_type; error : out err_code);
\end{lstlisting}
Changes only the mux mode configuration.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $mux$ - The new mux mode configuration value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_gain(self : in out ADS1015_record;
                  gain : pga_type; error : out err_code);
\end{lstlisting}
Changes only the converter gain value.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $gain$ - The new gain value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_continuous(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}
\begin{lstlisting}
procedure set_1shot(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in single shot mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Start a conversion when in single shot mode.  No effect in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
function conversion_done(self : in out ADS1015_record; error : out err_code)
    return Boolean;
\end{lstlisting}
Checks if conversion is in progress.  Will always return \constant{False} (conversion in progress) while in continuous mode.  Returns \constant{True} when no conversion is in progress.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns a conversion in progress flag.
\end{itemize}

\begin{lstlisting}
function get_result(self : in out ADS1015_record; error : out err_code)
    return uint12;
\end{lstlisting}
Returns the conversion value.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns the conversion value
\end{itemize}

\subsection{\package{BBS.embed.i2c.BME280}}
This is a driver for the Bosch BME280 temperature, pressure, and humidity sensor that attaches to an I2C bus \cite{BME280}.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BME280 sensor and is intended for use in the \function{configure} call.

\begin{lstlisting}
procedure configure(self : in out BME280_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure a BME280 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BME280 device to configure.
  \item $port$ - The I2C bus object that the BME280 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : BME280_record; error : out err_code);
\end{lstlisting}
Instruct the BME280 to start converting temperature, pressure, and humidity readings.  These are converted at the same time.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BME280_record; error : out err_code) return boolean;
\end{lstlisting}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
procedure read_data(self : in out BME280_record; error : out err_code);
\end{lstlisting}
Instructs the BME280 to read the converted temperature, pressure, and humidity values into BME280 object and compute calibrated values.  There is less overhead to read all three at once.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure get_raw(self : BME280_record; raw_temp : out uint32;
                  raw_press : out uint32; raw_hum : out uint32);
\end{lstlisting}
Return the raw, uncompensated values after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $raw\_temp$ - The raw temperature value.
  \item $raw\_press$ - The raw pressure value.
  \item $raw\_hum$ - The raw humidity value.
\end{itemize}

\begin{lstlisting}
function get_t_fine(self : BME280_record) return int32;
\end{lstlisting}
Returns the \package{t\_fine} value after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the \package{t\_fine} value.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.01\degree{}C.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of 0.01\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return BBS.units.temp_c;
function get_temp(self : BME280_record) return BBS.units.temp_f;
function get_temp(self : BME280_record) return BBS.units.temp_k;
\end{lstlisting}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is $\frac{1}{256}$Pa.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of $\frac{1}{256}$Pa.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return BBS.units.press_p;
function get_press(self : BME280_record) return BBS.units.press_mb;
function get_press(self : BME280_record) return BBS.units.press_atm;
function get_press(self : BME280_record) return BBS.units.press_inHg;
\end{lstlisting}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated relative humidity as an \datatype{Integer}.  The LSB unit is $\frac{1}{1024}$\% humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity in units of $\frac{1}{1024}$\% humidity.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return float;
\end{lstlisting}
Returns the relative humidity as a percentage relative humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity as a percentage relative humidity.
\end{itemize}

\subsection{\package{BBS.embed.i2c.BMP180}}
This is a driver for the Bosch BMP180 temperature and pressure sensor that attaches to an I2C bus \cite{BMP180}.  It has been discontinued by Bosch and is not recommended for new projects.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BMP180 sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Conversion Kind \\
    \hline
    \constant{cvt\_temp} & Convert Temperature \\
    \constant{cvt\_press0} & Convert pressure with no oversampling \\
    \constant{cvt\_press1} & Convert pressure with oversampling of two \\
    \constant{cvt\_press2} & Convert pressure with oversampling of four  \\
    \constant{cvt\_press3} & Convert pressure with oversampling of eight  \\
  \end{tabular}
  \caption{Constants for BMP180 Conversion Kinds}
  \label{tbl:BMP180Conv}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out BMP180_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure a BMP180 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BMP180 device to configure.
  \item $port$ - The I2C bus object that the BMP180 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out BMP180_record;
                           kind : uint8; error : out err_code);
\end{lstlisting}
Instruct the BMP180 to start converting temperature or pressure.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $kind$ - The kind of conversion to start.  See Table \ref{tbl:BMP180Conv} for options.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BMP180_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return float;
\end{lstlisting}
Returns the calibrated temperature value as a \datatype{Float} in \degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature as a \datatype{Float} in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.1\degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_c;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_f;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_k;
\end{lstlisting}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.  \item $error$ - The error code from any I2C transactions.

  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is 1Pa.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_p;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_mb;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_atm;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_inHg;
\end{lstlisting}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\subsection{\package{BBS.embed.i2c.L3GD20H}}
This is a driver for the STMicrosystems L3GD20H three-axis digital output gyroscope \cite{L3GD20}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the L3GD20H sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fs\_245dps} & Full scale is 245\degree{}/S (default) \\
    \constant{fs\_500dps} & Full scale is 500\degree{}/S \\
    \constant{fs\_2000dps} & Full scale is 2000\degree{}/S \\
  \end{tabular}
  \caption{Constants for L3GD20H Full-Scale Deflection}
  \label{tbl:L3GD20HDef}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{zyx\_or} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{z\_or} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{y\_or} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{x\_or} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{zyxda} & X,Y,Z axis new data available \\
    \constant{zda} & Z axis new data available \\
    \constant{yda} & Y axis new data available \\
    \constant{xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for L3GD20H Status}
  \label{tbl:L3GD20HStat}
\end{center}
\end{table}

Two utility datatypes are defined for holding rotations.  The first,  \datatype{rotations} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw rotation values from the sensor.  The second, \datatype{rotations\_dps} is similar, but the components are all of type \datatype{BBS.units.rot\_d\_s} for rotation in degrees per second.

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; deflection : uint8; error : out err_code);
\end{lstlisting}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $deflection$ - Set the full-scale deflection (See constants in Table \ref{tbl:L3GD20HDef}).
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : L3GD20H_record; error : out err_code)
    return integer;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the rotation around the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations;
\end{lstlisting}
Return a \datatype{rotations} record containing the raw sensor values for the rotations around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : L3GD20H_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
\end{lstlisting}
Return the rotation around the specified axis, $x$, $y$, or $z$ as a \datatype{rotations\_dps} containing the rotation in \degree{}/S.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations_dps;
\end{lstlisting}
Return a \datatype{otations\_dps} record containing the rotation in \degree{}/S around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_status(self : L3GD20H_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the device status.  The constants in Table \ref{tbl:L3GD20HStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function data_ready(self : L3GD20H_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
 function measure_offsets(self : in out L3GD20H_record) return boolean;
\end{lstlisting}
When stationary, the sensors may not report 0.  This function should be called when the sensor is stationary.  It reads the rotations several times and averages the results.  This is used to calculate offset values.  The offset values are used when returning the rotations in \datatype{rotations\_dps}.

This function returns \constant{True} if the measurement was successful - that is all of the values measured are reasonably close to the mean.  If it returns false, the sensor may be moving.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the offset measurement was successful.
\end{itemize}

\subsection{\package{BBS.embed.i2c.LSM303DLHC}}
This is a driver for the STMicrosystems LSM303DLHC three-axis digital output gyroscope \cite{LSM303DLHC}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr\_accel} is the I2C address of the LSM303DLHC accelerometer sensor; the constant \constant{addr\_mag} is the I2C address of the magnetometer sensor.  They are intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fs\_2g} & Full scale is 2G (default) \\
    \constant{fs\_4g} & Full scale is 4G \\
    \constant{fs\_8g} & Full scale is 8G \\
    \constant{fs\_16gs} & Full scale is 16G \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Accelerometer}
  \label{tbl:LSM303DLHCafs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{accel\_stat\_zyxor} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zor} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_yor} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_xorr} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zyxda} & X,Y,Z axis new data available \\
    \constant{accel\_stat\_zda} & Z axis new data available \\
    \constant{accel\_stat\_yda} & Y axis new data available \\
    \constant{accel\_stat\_xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Accelerometer Status}
  \label{tbl:LSM303DLHCaStat}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fa\_1\_3\_gauss} & Full scale is 1.3 gauss \\
    \constant{fs\_1\_9\_gauss} & Full scale is 1.9 gauss \\
    \constant{fs\_2\_5\_gauss} & Full scale is 2.5 gauss \\
    \constant{fs\_4\_0\_gauss} & Full scale is 4.0 gauss\\
    \constant{fs\_4\_7\_gauss} & Full scale is 4.7 gauss \\
    \constant{fs\_5\_6\_gauss} & Full scale is 5.6 gauss \\
    \constant{fs\_8\_1\_gauss} & Full scale is 8.1 gauss\\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Magnetometer}
  \label{tbl:LSM303DLHCmfs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{mag\_lock} & Data output register lock. \\
    \constant{mag\_drdy} & Data ready \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Magnetometer Status}
  \label{tbl:LSM303DLHCmStat}
\end{center}
\end{table}

Two utility datatypes are defined for holding accelerations.  The first,  \datatype{accelerations} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw acceleration values from the sensor.  The second, \datatype{accelerations\_g} is similar, but the components are all of type \datatype{BBS.units.accel\_g} for acceleration in units on 1 earth gravity.

Two utility datatypes are defined for holding magnetic fields.  The first,  \datatype{magnetism} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw magnetometer values from the sensor.  The second, \datatype{magnetism\_gauss} is similar, but the components are all of type \datatype{BBS.units.mag\_g} for magnetism in units on 1 gauss.

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record; port : i2c_interface;
                    accel : addr7; mag : addr7; error : out err_code);
\end{lstlisting}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $accel$ - The I2C address of the device accelerometer.
  \item $mag$ - The I2C address of the device magnetometer.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record;
                    port : i2c_interface; addr_accel : addr7; addr_mag : addr7;
                    accel_fs : uint8; mag_fs : uint8; error : out err_code);
\end{lstlisting}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $addr\_accel$ - The I2C address of the device accelerometer.
  \item $addr\_mag$ - The I2C address of the device magnetometer.
  \item $accel\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCafs}.
  \item $mag\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCmfs}.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure calibrate_accel(self : in out LSM303DLHC_record);
\end{lstlisting}
The calibrate accel procedure can be called when the sensor is stationary in a 1G acceleration or gravitational field.  It takes multiple measurements of the X, Y, and Z acceleration and computes the average of $X^2 + Y^2 + Z^2$.  This value should be 1.0.  A more sophisticated approach would be to compute a calibration value for each of the axis separately, but that would require the sensor to be precisely positioned three time.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to calibrate.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations;
\end{lstlisting}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
\end{lstlisting}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.accel\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.accel\_g} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations_g;
\end{lstlisting}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations\_g} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_accel_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the accelerometer status.  The constants in Table \ref{tbl:LSM303DLHCaStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function accel_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the device temperature as an \datatype{Integer} in units of $\frac{1}{8}$\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in units of $\frac{1}{8}$\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return float;
\end{lstlisting}
Return the device temperature as a \datatype{Float} in units of 1\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{Float} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the magnetic field along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism;
\end{lstlisting}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
\end{lstlisting}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.mag\_g} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{BBS.units.mag\_g} representing the magnetic field along the specified axis in units of gauss.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism_gauss;
\end{lstlisting}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism\_gauss} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism\_gauss} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_mag_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the magnetometer status.  The constants in Table \ref{tbl:LSM303DLHCmStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function mag_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP4725}}
This is a driver for the Microchip MCP4725 digital to analog convertor that attaches to an I2C bus \cite{MCP4725}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Command \\
    \hline
    \constant{Fast\_Write} & Fast write. \\
    \constant{Write\_CMD} & Write CMD. \\
    \constant{Write\_EEPROM} & Write EEPROM. \\
  \end{tabular}
  \caption{Constants for MCP4725 Commands}
  \label{tbl:MCP4725cmd}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Power-Down Mode \\
    \hline
    \constant{PD\_Normal} & Normal mode. \\
    \constant{PD\_1k} & 1k$\Omega$ to groupd. \\
    \constant{PD\_100k} & 100k$\Omega$ to ground. \\
    \constant{PD\_500k} & 500k$\Omega$ to ground. \\
  \end{tabular}
  \caption{Constants for MCP4725 Power-Down Modes}
  \label{tbl:MCP4725pdm}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out MCP4725_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP4725 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP4725 device to configure.
  \item $port$ - The I2C bus object that the MCP4725 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; value : uint12;
              err : out err_code);
\end{lstlisting}
The DAC is only single channel, so this just sets the value using fast write and PD normal mode.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $value$ - The output value to use for the DAC.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; cmd : CMD_type; mode : Mode_type;
              value : uint12; err : out err_code);
\end{lstlisting}
General set command.  Use the defined constants for the command and mode.  Other values may cause unexpected behavior.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $cmd$ - The command to use.  See Table \ref{tbl:MCP4725cmd} for available commands.
  \item $mode$ - The power-down mode to use.  See Table \ref{tbl:MCP4725pdm} for available modes.
  \item $value$ - The output value to use for the command and mode.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23008}}
This is a driver for the Microchip MCP23008 8-bit I/O port extender\cite{MCP23008}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCB23008_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP23008 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $port$ - The I2C bus object that the MCP23008 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCB23008_record; dir : uint8;
                  error : out err_code);
\end{lstlisting}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $dir$ - The \datatype{uint8} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCB23008_record; data : uint8;
                   error : out err_code);
\end{lstlisting}
Sets the output bits.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $data$ - The \datatype{uint8} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function read_data(self : MCB23008_record; error : out err_code)
   return uint8;
\end{lstlisting}
Read the port.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint8}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23017}}
This is a driver for the Microchip MCP23017 8-bit I/O port extender\cite{MCP23017}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCP23017_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP23017 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $port$ - The I2C bus object that the MCP23017 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_dir(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the direction bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_polarity(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Set the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the polarity bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_polarity(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the polarity bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_pullup(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Enable/Disable weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the pullup bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_pullup(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pullup bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCP23017_record; data : uint16;
                   error : out err_code);
\end{lstlisting}
Sets the output bits.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to set.
  \item $data$ - The \datatype{uint16} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_data(self : MCP23017_record; error : out err_code)
                   return uint16;
\end{lstlisting}
Read the port.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint16}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.PCA9685}}
This is a driver for the NXP Semiconductors PCA9685 16-channel, 12-bit PWM with I2C bus LED controller\cite{PCA9685}.  The driver does not support all of the options that the device has, but these can be added if needed.  The device can be configured to respond to one of four different I2C addresses.  The constants \constant{addr\_0} through \constant{addr\_3} are defined for these addresses.

In addition to controlling LEDs, it can control other PWM devices such as servo motors.  Note that LED brightness is controlled by the duty cycle and any duty cycle is valid.  Servos are controlled by the pulse width which should range from 1.5 to 2.5 mS.  See Table \ref{tbl:PCA9685Servo} for some measured values.  Note that all measured numbers are approximate.  There are probably a few  counts left before hitting full scale movement.  It's also entirely possible  that these values may vary with time, temperature, or other factors.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l|l}
    Servo & Min-position & Max-position \\
    \hline
    SG90 & 500mS & 2100mS \\
    SG99 & 450mS & 2050mS \\
    SG5010 & 500mS & 2100mS \\
  \end{tabular}
  \caption{Measured Values for PCA9685 Controlling Servos}
  \label{tbl:PCA9685Servo}
\end{center}
\end{table}

There are some things to keep in mind:
\begin{enumerate}
  \item Test your own servos to determine their appropriate values.
  \item If you want any sort of precision, you need some sort of position feed-back to the program.
  \item The documentation that says that the pulse width for servos should range from 1.5 to 2.5 mS may not be accurate.
\end{enumerate}

PWM channels are 0 to 15.  Channel 16 is the all call channel.  For each channel there is a 12 bit counter and two thresholds: the on and the off threshold.  When the counter is equal to the on threshold, the output turns on.  When the counter is equal to the off threshold, the output turns off.  This allows the pulses to be staggered between the channels, if needed.

For driving servo motors, the \datatype{servo\_range} datatype is defined as a \datatype{Float} with a range from -1.0 to 1.0.  Once the \function{set\_servo\_range} procedure has been called, the \function{set\_servo} procedure can be used to set the servo position using \datatype{servo\_range} rather than figuring out the settings for the duty cycle.  Thus, when changing between servos with different characteristics, all that needs to change is the \function{set\_servo\_range} call.

\begin{lstlisting}
procedure configure(self : in out PS9685_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the PCA9685 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $port$ - The I2C bus object that the PCA9685 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : PS9685_record; chan : channel;
              on : uint12; off : uint12; error : out err_code);
\end{lstlisting}
Set on and off times for a specific channel.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $on$ - The on time for the channel.
  \item $off$ - The off time for the channel.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_full_on(self : PS9685_record; chan : channel;
                      error : out err_code);
\end{lstlisting}
Sets the specified channel to full on.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_full_off(self : PS9685_record; chan : channel;
                       error : out err_code);
\end{lstlisting}
Sets the specified channel to full off.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure sleep(self : PS9685_record; state : boolean;
                error : out err_code);
\end{lstlisting}
If state is \constant{True}, send the device to sleep, otherwise wake it up.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $state$ - \constant{True} for sleep, \constant{False} for wake.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_servo_range(self : in out PS9685_record; chan : channel;
                          min : uint12; max : uint12);
\end{lstlisting}
Sets the maximum and minimum duty cycles for a channel.  Once these are set, a servo motor can be controlled using the \function{set\_servo} procedure using a servo position in the range on -1.0 to 1.0.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $min$ - The minimum duty cycle for the servo, corresponding to servo position -1.0.
  \item $max$ - The maximum duty cycle for the servo, corresponding to servo position 1.0.
\end{itemize}

\begin{lstlisting}
procedure set_servo(self : PS9685_record; chan : channel;
                    position : servo_range; error : out err_code);
\end{lstlisting}
Once the servo range has been set by the \function{set\_servo\_range} procedure, the servo can be controlled by this function using a servo position from -1.0 to 1.0 rather than the duty cycle.
\begin{itemize}
  \item $self$ - The PCA9685 device to configure.
  \item $chan$ - The channel number.
  \item $position$ - The servo position in a range from -1.0 to 1.0.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\subsection{\package{BBS.embed.SPI.RA8875}}
This is the driver for the RAiO RA8875 LCD controller that attaches to the SPI bus\cite{RA8875}.  There are a couple of hardware considerations.  First, it appears that the RA8875 does not tri-state its SPI output, which means that it doesn't work well with other devices on the SPI bus.  This can be fixed by adding a tri-state buffer.  Second, while the RA8875 operates at 3.3V, the LCD I used requires 5V for the backlight.  This is not insurmountable, but something to be aware of.

The intention of this driver is to provide an Ada interface to the various text and graphics primitives offered by the RA8875.  While it works, it still needs some work and should be considered to be experimental.  Use at your own risk, or you can use this as a starting point for writing your own driver.

There are a number of constants defined.  I expect that most of these are used internal to the driver and should be moved out of the spec.  There are also some types that are used in the API.  These are documented below.

\begin{lstlisting}
   type RA8875_sizes is (RA8875_480x272, RA8875_800x480);
\end{lstlisting}
The datatype \datatype{RA8875\_sizes} is an enumeration defined for the screen sizes supported by the RA8875.  The sizes supported by the RA8875 are 320x240, 320x480, 480x272, 640x480, and 800x480.  Right now I only have an 800x480 panel for testing so nothing is tested for other sizes.

\begin{lstlisting}
\end{lstlisting}
\begin{lstlisting}
   ----------------------------------------------------------------------------
   -- Constants and types for RA8875 registers and bits
   --
   type RA8875_LAYER is (LAYER1, LAYER2);
   --
   -- Power and display control register
   RA8875_PWRR : constant uint8 := 16#01#;
   RA8875_PWRR_DISPON : constant uint8 := 16#80#;
   RA8875_PWRR_DISPOFF : constant uint8 := 16#00#;
   RA8875_PWRR_SLEEP : constant uint8 := 16#02#;
   RA8875_PWRR_NORMAL : constant uint8 := 16#00#;
   RA8875_PWRR_SOFTRESET : constant uint8 := 16#01#;
   --
   -- Memory read/write command
   RA8875_MRWC : constant uint8 := 16#02#;
   --
   -- Pixel clock setting register
   RA8875_PCSR : constant uint8 := 16#04#;
   RA8875_PCSR_PDATR : constant uint8 := 16#00#;
   RA8875_PCSR_PDATL : constant uint8 := 16#80#;
   RA8875_PCSR_CLK : constant uint8 := 16#00#;
   RA8875_PCSR_2CLK : constant uint8 := 16#01#;
   RA8875_PCSR_4CLK : constant uint8 := 16#02#;
   RA8875_PCSR_8CLK : constant uint8 := 16#03#;
   --
   -- Serial flash/ROM configuration register
   RA8875_SROC : constant uint8 := 16#05#;
   --
   -- Serial flash/ROM CLK setting register
   RA8875_SFCLR : constant uint8 := 16#06#;
   --
   -- System configuration register
   RA8875_SYSR : constant uint8 := 16#10#;
   RA8875_SYSR_8BPP : constant uint8 := 16#00#;
   RA8875_SYSR_16BPP : constant uint8 := 16#0C#;
   RA8875_SYSR_MCU8 : constant uint8 := 16#00#;
   RA8875_SYSR_MCU16 : constant uint8 := 16#03#;
   --
   -- General purpose input
   RA8875_GPI : constant uint8 := 16#12#;
   --
   -- General purpose output
   RA8875_GPO : constant uint8 := 16#13#;
   --
   -- Horizontal Display Width Register
   RA8875_HDWR : constant uint8 := 16#14#;
   --
   -- Horizontal non-display fine tuning option register
   RA8875_HNDFTR : constant uint8 := 16#15#;
   RA8875_HNDFTR_DE_HIGH : constant uint8 := 16#00#;
   RA8875_HNDFTR_DE_LOW : constant uint8 := 16#80#;
   --
   -- LCD Horizontal non-display period register
   RA8875_HNDR : constant uint8 := 16#16#;
   --
   -- HSYNC start position register
   RA8875_HSTR : constant uint8 := 16#17#;
   --
   -- HSYNC pulse width register
   --
   RA8875_HPWR : constant uint8 := 16#18#;
   RA8875_HPWR_LOW : constant uint8 := 16#00#;
   RA8875_HPWR_HIGH : constant uint8 := 16#80#;
   --
   -- LCD vertical display height register 0
   RA8875_VDHR0 : constant uint8 := 16#19#;
   --
   -- LCD vertical display height register 1
   RA8875_VDHR1 : constant uint8 := 16#1A#;
   --
   -- LCD vertical non-display period register 0
   RA8875_VNDR0 : constant uint8 := 16#1B#;
   --
   -- LVD vertical non-display period register 1
   RA8875_VNDR1 : constant uint8 := 16#1C#;
   --
   -- VSYNC start position register 0
   RA8875_VSTR0 : constant uint8 := 16#1D#;
   --
   -- VSYNC start position register 1
   RA8875_VSTR1 : constant uint8 := 16#1E#;
   --
   -- VSYNC pulse width register
   RA8875_VPWR : constant uint8 := 16#1F#;
   RA8875_VPWR_LOW : constant uint8 := 16#00#;
   RA8875_VPWR_HIGH : constant uint8 := 16#80#;
   --
   -- Display configuration register
   RA8875_DPCR : constant uint8 := 16#20#;
   RA8875_DPCR_1LAYER : constant uint8 := 16#00#;
   RA8875_DPCR_2LAYER : constant uint8 := 16#80#;
   RA8875_DPCR_HDIR0 : constant uint8 := 16#00#;
   RA8875_DPCR_HDIR1 : constant uint8 := 16#08#;
   RA8875_DPCR_VDIR0 : constant uint8 := 16#00#;
   RA8875_DPCR_VDIR1 : constant uint8 := 16#04#;
   --
   -- Font control register 0
   RA8875_FNCR0 : constant uint8 := 16#21#;
   RA8875_FNCR0_CGRAM : constant uint8 := 16#80#;
   RA8875_FNCR0_EXTCR : constant uint8 := 16#20#;
   type RA8875_FNCR0_Code_Page is
     (RA8875_FNCR0_ISO8859_1, RA8875_FNCR0_ISO8859_2,
      RA8875_FNCR0_ISO8859_3, RA8875_FNCR0_ISO8859_4);
   --
   -- Font control register 1
   RA8875_FNCR1 : constant uint8 := 16#22#;
   RA8875_FNCR1_ALIGN : constant uint8 := 16#80#;
   RA8875_FNCR1_TRANS : constant uint8 := 16#40#;
   RA8875_FNCR1_ROT : constant uint8 := 16#10#;
   RA8875_FNCR1_HLARGE : constant uint8 := 16#0C#;
   RA8875_FNCR1_VLARGE : constant uint8 := 16#03#;
   --
   -- CGRAM select register
   RA8875_CGSR : constant uint8 := 16#23#;
   --
   -- Horizontal scroll offset register 0
   RA8875_HOFS0 : constant uint8 := 16#24#;
   --
   -- Horizontal scroll offset register 1
   RA8875_HOFS1 : constant uint8 := 16#25#;
   --
   -- Vertical scroll offset register 0
   RA8875_VOFS0 : constant uint8 := 16#26#;
   --
   -- Vertical scroll offset register 1
   RA8875_VOFS1 : constant uint8 := 16#27#;
   --
   -- Font line distance setting register
   RA8875_FLDR : constant uint8 := 16#29#;
   --
   -- Font write cursor horizontal position register 0
   RA8875_F_CURXL : constant uint8 := 16#2A#;
   --
   -- Font write cursor horizontal position register 1
   RA8875_F_CURXH : constant uint8 := 16#2B#;
   --
   -- Font write cursor vertical position register 0
   RA8875_F_CURYL : constant uint8 := 16#2C#;
   --
   -- Font write cursor vertical position register 1
   RA8875_F_CURYH : constant uint8 := 16#2D#;
   --
   -- Font write type setting register
   RA8875_FWTSR : constant uint8 := 16#2E#;
   --
   -- Serial font ROM setting
   RA8875_SFRS : constant uint8 := 16#2F#;
   --
   -- Horizontal start point 0 of active window
   RA8875_HSAW0 : constant uint8 := 16#30#;
   --
   -- Horizontal start point 1 of active window
   RA8875_HSAW1 : constant uint8 := 16#31#;
   --
   -- Vertical start point 0 of active window
   RA8875_VSAW0 : constant uint8 := 16#32#;
   --
   -- Vertical start point 1 of active window
   RA8875_VSAW1 : constant uint8 := 16#33#;
   --
   -- Horizontal end point 0 of active window
   RA8875_HEAW0 : constant uint8 := 16#34#;
   --
   -- Horizontal end point 1 of active window
   RA8875_HEAW1 : constant uint8 := 16#35#;
   --
   -- Vertical end point 0 of active window
   RA8875_VEAW0 : constant uint8 := 16#36#;
   --
   -- Vertical end point 1 of active window
   RA8875_VEAW1 : constant uint8 := 16#37#;
   --
   -- Horizontal start point 0 of scroll window
   RA8875_HSSW0 : constant uint8 := 16#38#;
   --
   -- Horizontal start point 1 of scroll window
   RA8875_HSSW1 : constant uint8 := 16#39#;
   --
   -- Vertical start point 0 of scroll window
   RA8875_VSSW0 : constant uint8 := 16#3A#;
   --
   -- Vertical start point 1 of scroll window
   RA8875_VSSW1 : constant uint8 := 16#3B#;
   --
   -- Horizontal end point 0 of scroll window
   RA8875_HESW0 : constant uint8 := 16#3C#;
   --
   -- Horizontal end point 1 of scroll window
   RA8875_HESW1 : constant uint8 := 16#3D#;
   --
   -- Vertical end point 0 of scroll window
   RA8875_VESW0 : constant uint8 := 16#3E#;
   --
   -- Vertical end point 1 of scroll window
   RA8875_VESW1 : constant uint8 := 16#3F#;
   --
   -- Memory write control register 0
   RA8875_MWCR0 : constant uint8 := 16#40#;
   RA8875_MWCR0_GFXMODE : constant uint8 := 16#00#;
   RA8875_MWCR0_TXTMODE : constant uint8 := 16#80#;
   RA8875_MWCR0_CURVIS : constant uint8 := 16#40#;
   RA8875_MWCR0_CURBLINK : constant uint8 := 16#20#;
   type RA8875_MWCR0_MODE is (graphic, text);
   type RA8875_MWCR0_CURDIR is (LRTD, RLTD, TDLR, DTLR);
   RA8875_MWCR0_CURDIR_SCALE : constant uint8 := 16#04#;
   RA8875_MWCR0_WRITE_NOINCR : constant uint8 := 16#02#;
   RA8875_MWCR0_READ_NOINCR : constant uint8 := 16#01#;
   --
   -- Memory write control register 1
   RA8875_MWCR1 : constant uint8 := 16#41#;
   RA8875_NWCR1_GCURS_EN : constant uint8 := 16#80#;
   RA8875_MWCR1_CUR_SEL_SCALE : constant uint8 := 16#10#;
   RA8875_MWCR_WRITE_DEST_SCALE : constant uint8 := 16#04#;
   type RA8875_MWCR1_GCURS_ENABLE is (disable, enable);
   type RA8875_MWCR1_GCURS_SET is range 0 .. 7;
   type RA8875_MWCR1_WRITE_DEST is (LAYER, CGRAM, GCURS, PATTERN);
   --
   -- Blink time control register
   RA8875_BTCR : constant uint8 := 16#44#;
   --
   -- Memory read cursor direction
   RA8875_MRCD : constant uint8 := 16#45#;
   --
   -- Memory write cursor horizontal position register 0
   RA8875_CURH0 : constant uint8 := 16#46#;
   --
   -- Memory write cursor horizontal position register 1
   RA8875_CURH1 : constant uint8 := 16#47#;
   --
   -- Memory write cursor vertical position register 0
   RA8875_CURV0 : constant uint8 := 16#48#;
   --
   -- Memory write cursor vertical position register 1
   RA8875_CURV1 : constant uint8 := 16#49#;
   --
   -- Memory read cursor horizontal position register 0
   RA8875_RCURH0 : constant uint8 := 16#4A#;
   --
   -- Memory read cursor horizontal position register 1
   RA8875_RCURH1 : constant uint8 := 16#4B#;
   --
   -- Memory read cursor vertical position register 0
   RA8875_RCURV0 : constant uint8 := 16#4C#;
   --
   -- Memory read cursor vertical position register 1
   RA8875_RCURV1 : constant uint8 := 16#4D#;
   --
   -- Font write cursor and memory write cursor horizontal size register
   RA8875_CURHS : constant uint8 := 16#4E#;
   --
   -- Font write cursor and memory write cursor vertical size register
   RA8875_CURVS : constant uint8 := 16#4F#;
   --
   -- Block transfer engine (BTE) control register 0
   RA8875_BECR0 : constant uint8 := 16#50#;
   --
   -- Block transfer engine (BTE) control register 1
   RA8875_BECR1 : constant uint8 := 16#51#;
   --
   -- Layer transparency register 0
   RA8875_LTPR0 : constant uint8 := 16#52#;
   RA8875_LTPR0_MODE_SCALE : uint8 := 16#40#;
   type RA8875_LTPR0_SCROLL_MODE is (LAYER12_SIMULTANEOUS, LAYER1_ONLY,
                                     LAYER2_ONLY, BUFFERED);
   RA8875_LTPR0_FLOAT_ENABLE : uint8 := 16#20#;
   type RA8875_LTPR0_DISP_MODE is (ONLY_LAYER1, ONLY_LAYER2, LIGHTEN, TRANSPARENT,
                                     BOOL_OR, BOOL_AND, FLOATING, RESERVED);
   --
   -- Layer transparency register 1
   RA8875_LTPR1 : constant uint8 := 16#53#;
   --
   -- Horizontal source point 0 of BTE
   RA8875_HSBE0 : constant uint8 := 16#54#;
   --
   -- Horizontal source point 1 of BTE
   RA8875_HSBE1 : constant uint8 := 16#55#;
   --
   -- Vertical source point 0 of BTE
   RA8875_VSBE0 : constant uint8 := 16#56#;
   --
   -- Vertical source point 1 of BTE
   RA8875_VSBE1 : constant uint8 := 16#57#;
   --
   -- Horizontal destination point 0 of BTE
   RA8875_HDBE0 : constant uint8 := 16#58#;
   --
   -- Horizontal destination point 1 of BTE
   RA8875_HDBE1 : constant uint8 := 16#59#;
   --
   -- Vertical destination point 0 of BTE
   RA8875_VDBE0 : constant uint8 := 16#5A#;
   --
   -- Vertical destination point 1 of BTE
   RA8875_VDBE1 : constant uint8 := 16#5B#;
   --
   -- BTE width register 0
   RA8875_BEWR0 : constant uint8 := 16#5C#;
   --
   -- BTE width register 1
   RA8875_BEWR1 : constant uint8 := 16#5D#;
   --
   -- BTE height register 0
   RA8875_BEHR0 : constant uint8 := 16#5E#;
   --
   -- BTE height register 1
   RA8875_BEHR1 : constant uint8 := 16#5F#;
   --
   -- Background color register 0 (red)
   RA8875_BGCR0 : constant uint8 := 16#60#;
   --
   -- Background color register 1 (green)
   RA8875_BGCR1 : constant uint8 := 16#61#;
   --
   -- Background color register 2 (blue)
   RA8875_BGCR2 : constant uint8 := 16#62#;
   --
   -- Foreground color register 0 (red)
   RA8875_FGCR0 : constant uint8 := 16#63#;
   --
   -- Foreground color register 1 (green)
   RA8875_FGCR1 : constant uint8 := 16#64#;
   --
   -- Foreground color register 2 (blue)
   RA8875_FGCR2 : constant uint8 := 16#65#;
   --
   -- Pattern set no for BTE
   RA8875_PTNO : constant uint8 := 16#66#;
   --
   -- Background color register for transparent 0 (red)
   RA8875_BGTR0 : constant uint8 := 16#67#;
   --
   -- Background color register for transparent 1 (green)
   RA8875_BGTR1 : constant uint8 := 16#68#;
   --
   -- Background color register for transparent 2 (blue)
   RA8875_BGTR2 : constant uint8 := 16#69#;
   --
   -- Touch panel control register 0
   RA8875_TPCR0 : constant uint8 := 16#70#;
   RA8875_TPCR0_ENABLE : constant uint8 := 16#80#;
   RA8875_TPCR0_DISABLE : constant uint8 := 16#00#;
   RA8875_TPCR0_WAIT_512CLK : constant uint8 := 16#00#;
   RA8875_TPCR0_WAIT_1024CLK : constant uint8 := 16#10#;
   RA8875_TPCR0_WAIT_2048CLK : constant uint8 := 16#20#;
   RA8875_TPCR0_WAIT_4096CLK : constant uint8 := 16#30#;
   RA8875_TPCR0_WAIT_8192CLK : constant uint8 := 16#40#;
   RA8875_TPCR0_WAIT_16384CLK : constant uint8 := 16#50#;
   RA8875_TPCR0_WAIT_32768CLK : constant uint8 := 16#60#;
   RA8875_TPCR0_WAIT_65536CLK : constant uint8 := 16#70#;
   RA8875_TPCR0_WAKEENABLE : constant uint8 := 16#08#;
   RA8875_TPCR0_WAKEDISABLE : constant uint8 := 16#00#;
   RA8875_TPCR0_ADCCLK_DIV1 : constant uint8 := 16#00#;
   RA8875_TPCR0_ADCCLK_DIV2 : constant uint8 := 16#01#;
   RA8875_TPCR0_ADCCLK_DIV4 : constant uint8 := 16#02#;
   RA8875_TPCR0_ADCCLK_DIV8 : constant uint8 := 16#03#;
   RA8875_TPCR0_ADCCLK_DIV16 : constant uint8 := 16#04#;
   RA8875_TPCR0_ADCCLK_DIV32 : constant uint8 := 16#05#;
   RA8875_TPCR0_ADCCLK_DIV64 : constant uint8 := 16#06#;
   RA8875_TPCR0_ADCCLK_DIV128 : constant uint8 := 16#07#;
   --
   -- Touch panel control register 1
   RA8875_TPCR1 : constant uint8 := 16#71#;
   RA8875_TPCR1_AUTO : constant uint8 := 16#00#;
   RA8875_TPCR1_MANUAL : constant uint8 := 16#40#;
   RA8875_TPCR1_VREFINT : constant uint8 := 16#00#;
   RA8875_TPCR1_VREFEXT : constant uint8 := 16#20#;
   RA8875_TPCR1_DEBOUNCE : constant uint8 := 16#04#;
   RA8875_TPCR1_NODEBOUNCE : constant uint8 := 16#00#;
   RA8875_TPCR1_IDLE : constant uint8 := 16#00#;
   RA8875_TPCR1_WAIT : constant uint8 := 16#01#;
   RA8875_TPCR1_LATCHX : constant uint8 := 16#02#;
   RA8875_TPCR1_LATCHY : constant uint8 := 16#03#;
   --
   -- Touch panel X high byte data register
   RA8875_TPXH : constant uint8 := 16#72#;
   --
   -- Touch panel Y high byte data register
   RA8875_TPYH : constant uint8 := 16#73#;
   --
   -- Touch panel X/Y low byte data register
   RA8875_TPXYL : constant uint8 := 16#74#;
   RA8875_TPXYL_TOUCHED : constant uint8 := 16#80#;
   RA8875_TPXYL_Y_LSB : constant uint8 := 16#0C#;
   RA8875_TPXYL_X_LSB : constant uint8 := 16#03#;
   --
   -- Graphic cursor horizontal register 0
   RA8875_GCHP0 : constant uint8 := 16#80#;
   --
   -- Graphic cursor horizontal register 1
   RA8875_GCHP1 : constant uint8 := 16#81#;
   --
   -- Graphic cursor vertical register 0
   RA8875_GCHV0 : constant uint8 := 16#82#;
   --
   -- Graphic cursor vertical register 1
   RA8875_GCHV1 : constant uint8 := 16#83#;
   --
   -- Graphics cursor color 0
   RA8875_GCC0 : constant uint8 := 16#84#;
   --
   -- Graphics cursor color 1
   RA8875_GCC1 : constant uint8 := 16#85#;
   --
   -- PLL control register 1
   RA8875_PLLC1 : constant uint8 := 16#88#;
   RA8875_PLLC1_PLLDIV2 : constant uint8 := 16#80#;
   RA8875_PLLC1_PLLDIV1 : constant uint8 := 16#00#;
   --
   -- PLL control register 2
   RA8875_PLLC2 : constant uint8 := 16#89#;
   RA8875_PLLC2_DIV1 : constant uint8 := 16#00#;
   RA8875_PLLC2_DIV2 : constant uint8 := 16#01#;
   RA8875_PLLC2_DIV4 : constant uint8 := 16#02#;
   RA8875_PLLC2_DIV8 : constant uint8 := 16#03#;
   RA8875_PLLC2_DIV16 : constant uint8 := 16#04#;
   RA8875_PLLC2_DIV32 : constant uint8 := 16#05#;
   RA8875_PLLC2_DIV64 : constant uint8 := 16#06#;
   RA8875_PLLC2_DIV128 : constant uint8 := 16#07#;
   --
   -- PWM Control registers.  Note that PWM1 and PWM use the same values, so
   -- there is no point defining separate constants for each.  Only the
   -- addresses are different.
   RA8875_P1CR : constant uint8 := 16#8A#;
   RA8875_P1DCR : constant uint8 := 16#8B#;
   RA8875_P2CR : constant uint8 := 16#8C#;
   RA8875_P2DCR : constant uint8 := 16#8D#;
   --
   -- Constants for PWM CR
   RA8875_PWMCR_ENABLE : constant uint8 := 16#80#;
   RA8875_PWMCR_DISABLE : constant uint8 := 16#00#;
   RA8875_PWMCR_CLKOUT : constant uint8 := 16#10#;
   RA8875_PWMCR_PWMOUT : constant uint8 := 16#00#;
   --
   -- Constants for PWM DCR
   RA8875_PWM_CLK_DIV1 : constant uint8 := 16#00#;
   RA8875_PWM_CLK_DIV2 : constant uint8 := 16#01#;
   RA8875_PWM_CLK_DIV4 : constant uint8 := 16#02#;
   RA8875_PWM_CLK_DIV8 : constant uint8 := 16#03#;
   RA8875_PWM_CLK_DIV16 : constant uint8 := 16#04#;
   RA8875_PWM_CLK_DIV32 : constant uint8 := 16#05#;
   RA8875_PWM_CLK_DIV64 : constant uint8 := 16#06#;
   RA8875_PWM_CLK_DIV128 : constant uint8 := 16#07#;
   RA8875_PWM_CLK_DIV256 : constant uint8 := 16#08#;
   RA8875_PWM_CLK_DIV512 : constant uint8 := 16#09#;
   RA8875_PWM_CLK_DIV1024 : constant uint8 := 16#0A#;
   RA8875_PWM_CLK_DIV2048 : constant uint8 := 16#0B#;
   RA8875_PWM_CLK_DIV4096 : constant uint8 := 16#0C#;
   RA8875_PWM_CLK_DIV8192 : constant uint8 := 16#0D#;
   RA8875_PWM_CLK_DIV16384 : constant uint8 := 16#0E#;
   RA8875_PWM_CLK_DIV32768 : constant uint8 := 16#0F#;
   --
   -- Memory clear register
   RA8875_MCLR : constant uint8 := 16#8E#;
   RA8875_MCLR_START : constant uint8 := 16#80#;
   RA8875_MCLR_STOP : constant uint8 := 16#00#;
   RA8875_MCLR_READSTATUS : constant uint8 := 16#80#;
   RA8875_MCLR_FULL : constant uint8 := 16#00#;
   RA8875_MCLR_ACTIVE : constant uint8 := 16#40#;
   --
   -- Draw line/circle/square control register
   RA8875_DCR : constant uint8 := 16#90#;
   RA8875_DCR_LINESQUTRI_START : constant uint8 := 16#80#;
   RA8875_DCR_LINESQUTRI_STOP : constant uint8 := 16#00#;
   RA8875_DCR_LINESQUTRI_STATUS : constant uint8 := 16#80#;
   RA8875_DCR_CIRCLE_START : constant uint8 := 16#40#;
   RA8875_DCR_CIRCLE_STATUS : constant uint8 := 16#40#;
   RA8875_DCR_CIRCLE_STOP : constant uint8 := 16#00#;
   RA8875_DCR_FILL : constant uint8 := 16#20#;
   RA8875_DCR_NOFILL : constant uint8 := 16#00#;
   RA8875_DCR_DRAWLINE : constant uint8 := 16#00#;
   RA8875_DCR_DRAWTRIANGLE : constant uint8 := 16#01#;
   RA8875_DCR_DRAWSQUARE : constant uint8 := 16#10#;
   --
   -- Draw line/square horizontal start address register 0
   RA8875_DLHSR0 : constant uint8 := 16#91#;
   --
   -- Draw line/square horizontal start address register 1
   RA8875_DLHSR1 : constant uint8 := 16#92#;
   --
   -- Draw line/square vertical start address register 0
   RA8875_DLVSR0 : constant uint8 := 16#93#;
   --
   -- Draw line/square vertical start address register 1
   RA8875_DLVSR1 : constant uint8 := 16#94#;
   --
   -- Draw line/square horizontal end address register 0
   RA8875_DLHER0 : constant uint8 := 16#95#;
   --
   -- Draw line/square horizontal end address register 1
   RA8875_DLHER1 : constant uint8 := 16#96#;
   --
   -- Draw line/square vertical end address register 0
   RA8875_DLVER0 : constant uint8 := 16#97#;
   --
   -- Draw line/square vertical end address register 1
   RA8875_DLVER1 : constant uint8 := 16#98#;
   --
   -- Draw circle center horizontal address register 0
   RA8875_DCHR0 : constant uint8 := 16#99#;
   --
   -- Draw circle center horizontal address register 1
   RA8875_DCHR1 : constant uint8 := 16#9A#;
   --
   -- Draw circle center vertical address register 0
   RA8875_DCHV0 : constant uint8 := 16#9B#;
   --
   -- Draw circle center vertical address register 1
   RA8875_DCHV1 : constant uint8 := 16#9C#;
   --
   -- Draw circle radius register
   RA8875_DCRR : constant uint8 := 16#9D#;
   --
   -- Draw ellipse/ellipse curve/circle square control register
   RA8875_ELLIPSE : constant uint8 := 16#A0#;
   RA8875_ELLIPSE_STATUS : constant uint8 := 16#80#;
   RA8875_ELLIPSE_START : constant uint8 := 16#80#;
   RA8875_ELLIPSE_FILL : constant uint8 := 16#40#;
   RA8875_ELLIPSE_SQR : constant uint8 := 16#20#;
   RA8875_ELLIPSE_CURVE : constant uint8 := 16#10#;
   type RA8875_ELLIPSE_PART is (RA8875_ELLIPSE_LL, RA8875_ELLIPSE_UL,
                                RA8875_ELLIPSE_UR, RA8875_ELLIPSE_LR);
   --
   -- Draw ellipse/circle square long axis setting register 0
   RA8875_ELL_A0 : constant uint8 := 16#A1#;
   --
   -- Draw ellipse/circle square long axis setting register 1
   RA8875_ELL_A1 : constant uint8 := 16#A2#;
   --
   -- Draw ellipse/circle square short axis setting register 0
   RA8875_ELL_B0 : constant uint8 := 16#A3#;
   --
   -- Draw ellipse/circle square short axis setting register 1
   RA8875_ELL_B1 : constant uint8 := 16#A4#;
   --
   -- Draw ellipse/circle square center horizontal address register 0
   RA8875_DEHR0 : constant uint8 := 16#A5#;
   --
   -- Draw ellipse/circle square center horizontal address register 1
   RA8875_DEHR1 : constant uint8 := 16#A6#;
   --
   -- Draw ellipse/circle square center vertical address register 0
   RA8875_DEVR0 : constant uint8 := 16#A7#;
   --
   -- Draw ellipse/circle square center vertical address register 1
   RA8875_DEVR1 : constant uint8 := 16#A8#;
   --
   -- Draw triangle point 2 horizontal address register 0
   RA8875_DTPH0 : constant uint8 := 16#A9#;
   --
   -- Draw triangle point 2 horizontal address register 1
   RA8875_DTPH1 : constant uint8 := 16#AA#;
   --
   -- Draw triangle point 2 vertical address register 0
   RA8875_DTPV0 : constant uint8 := 16#AB#;
   --
   -- Draw triangle point 2 vertical address register 1
   RA8875_DTPV1 : constant uint8 := 16#AC#;
   --
   -- DMA Source starting address reg 0
   RA8875_SSAR0 : constant uint8 := 16#B0#;
   --
   -- DMA Source starting address reg 1
   RA8875_SSAR1 : constant uint8 := 16#B1#;
   --
   -- DMA Source starting address reg 2
   RA8875_SSAR2 : constant uint8 := 16#B2#;
   --
   -- DMA Block width register 0 / DMA transfer number register 0
   RA8875_DTNR0 : constant uint8 := 16#B4#;
   --
   -- DMA Block width register 1
   RA8875_BWR1 : constant uint8 := 16#B5#;
   --
   -- DMA Block height register 0 / DMA transfer number register 1
   RA8875_DTNR1 : constant uint8 := 16#B6#;
   --
   -- DMA Block height register 1
   RA8875_BHR1 : constant uint8 := 16#B7#;
   --
   -- DMA source picture width register 0 / DMA transfer number register 2
   RA8875_DNTR2 : constant uint8 := 16#B8#;
   --
   -- DMA Source picture register 1
   RA8875_SPWR1 : constant uint8 := 16#B9#;
   --
   -- DMA configuration register
   RA8875_DMACR : constant uint8 := 16#BF#;
   --
   -- Key-Scan control register 1
   RA8875_KSCR1 : constant uint8 := 16#C0#;
   --
   -- Key-Scan control register 2
   RA8875_KSCR2 : constant uint8 := 16#C1#;
   --
   -- Key-Scan data register 0
   RA8875_KSRD0 : constant uint8 := 16#C2#;
   --
   -- Key-Scan data register 1
   RA8875_KSRD1 : constant uint8 := 16#C3#;
   --
   -- Key-Scan data register 2
   RA8875_KSRD2 : constant uint8 := 16#C4#;
   --
   -- Extra general purpose I/O register
   RA8875_GPIOX : constant uint8 := 16#C7#;
   --
   -- Floating window start address XA 0
   RA8875_FWSAXA0 : constant uint8 := 16#D0#;
   --
   -- Floating window start address XA 1
   RA8875_FWSAXA1 : constant uint8 := 16#D1#;
   --
   -- Floating window start address YA 0
   RA8875_FWSAYA0 : constant uint8 := 16#D2#;
   --
   -- Floating window start address YA 1
   RA8875_FWSAYA1 : constant uint8 := 16#D3#;
   --
   -- Floating window width 0
   RA8875_FWW0 : constant uint8 := 16#D4#;
   --
   -- Floating window width 1
   RA8875_FWW1 : constant uint8 := 16#D5#;
   --
   -- Floating window height 0
   RA8875_FWH0 : constant uint8 := 16#D6#;
   --
   -- Floating window height 1
   RA8875_FWH1 : constant uint8 := 16#D7#;
   --
   -- Floating window display X address 0
   RA8875_FWDXA0 : constant uint8 := 16#D8#;
   --
   -- Floating window display X address 1
   RA8875_FWDXA1 : constant uint8 := 16#D9#;
   --
   -- Floating window display Y address 0
   RA8875_FWDYA0 : constant uint8 := 16#DA#;
   --
   -- Floating window display Y address 1
   RA8875_FWDYA1 : constant uint8 := 16#DB#;
   --
   -- Serial flash/ROM direct access mode
   RA8875_SACS_MODE : constant uint8 := 16#E0#;
   --
   -- Serial flash/ROM direct access mode address
   RA8875_SACS_ADDR : constant uint8 := 16#E1#;
   --
   -- Serial flash/ROM direct access data read
   RA8875_SACS_DATA : constant uint8 := 16#E2#;
   --
   -- Interrupt control register 1
   RA8875_INTC1 : constant uint8 := 16#F0#;
   RA8875_INTC1_KEY : constant uint8 := 16#10#;
   RA8875_INTC1_DMA : constant uint8 := 16#08#;
   RA8875_INTC1_TP : constant uint8 := 16#04#;
   RA8875_INTC1_BTE : constant uint8 := 16#02#;
   --
   -- Interrupt control register 2
   RA8875_INTC2 : constant uint8 := 16#F1#;
   RA8875_INTC2_KEY : constant uint8 := 16#10#;
   RA8875_INTC2_DMA : constant uint8 := 16#08#;
   RA8875_INTC2_TP : constant uint8 := 16#04#;
   RA8875_INTC2_BTE : constant uint8 := 16#02#;
   ----------------------------------------------------------------------------
   -- Type definitions
   --
   -- Colors (RGB565)
   --
   type R5G6B5_color is record
      R : uint8 range 0 .. 31;
      G : uint8 range 0 .. 63;
      B : uint8 range 0 .. 31;
end record;
--
-- To match the 16 bit definition, add the following:
--
--     with pack, size => 16;
--   for R5G6B5_color use
--      record
--         B at 0 range 0 .. 4;
--         G at 0 range 5 .. 10;
--         R at 0 range 11 .. 15;
--      end record;
   --
   -- Define some common colors
   --
   R5G6B5_BLACK : constant R5G6B5_color := (R => 0, G => 0, B => 0);
   R5G6B5_BLUE : constant R5G6B5_color := (R => 0, G => 0, B => 31);
   R5G6B5_RED : constant R5G6B5_color := (R => 31, G => 0, B => 0);
   R5G6B5_GREEN : constant R5G6B5_color := (R => 0, G => 63, B => 0);
   R5G6B5_CYAN : constant R5G6B5_color := (R => 0, G => 63, B => 31);
   R5G6B5_MAGENTA : constant R5G6B5_color := (R => 31, G => 0, B => 31);
   R5G6B5_YELLOW : constant R5G6B5_color := (R => 31, G => 63, B => 0);
   R5G6B5_WHITE : constant R5G6B5_color := (R => 31, G => 63, B => 31);
   --
   -- Colors (RGB332)
   --
   type R3G3B2_color is record
      R : uint8 range 0 .. 7;
      G : uint8 range 0 .. 7;
      B : uint8 range 0 .. 3;
   end record
--
-- To match the 8 bit definition, add the following:
--
     with pack, size => 8;
   for R3G3B2_color use
      record
         B at 0 range 0 .. 1;
         G at 0 range 2 .. 4;
         R at 0 range 5 .. 7;
      end record;
   function R3G3B2_to_uint8 is new Ada.Unchecked_Conversion(Source => R3G3B2_color,
                                                            Target => uint8);
   function uint8_to_R3G3B2 is new Ada.Unchecked_Conversion(Source => uint8,
                                                            Target => R3G3B2_color);
   --
   -- Define some common colors
   --
   R3G3B2_BLACK : constant R3G3B2_color := (R => 0, G => 0, B => 0);
   R3G3B2_BLUE : constant R3G3B2_color := (R => 0, G => 0, B => 3);
   R3G3B2_RED : constant R3G3B2_color := (R => 7, G => 0, B => 0);
   R3G3B2_GREEN : constant R3G3B2_color := (R => 0, G => 7, B => 0);
   R3G3B2_CYAN : constant R3G3B2_color := (R => 0, G => 7, B => 3);
   R3G3B2_MAGENTA : constant R3G3B2_color := (R => 7, G => 0, B => 3);
   R3G3B2_YELLOW : constant R3G3B2_color := (R => 7, G => 7, B => 0);
   R3G3B2_WHITE : constant R3G3B2_color := (R => 7, G => 7, B => 3);
   --
   -- Graphics cursor
   --
   -- Cursor pixel value:
   -- 0 - GCC0 color
   -- 1 - GCC1 color
   -- 2 - Background color
   -- 3 - Inverse of background color
   --
   -- Note that the coordinates for GCursor are reversed from what one would
   -- expect.  The Y axis coordinate is the first array index and the X axis
   -- coordinate is the second array index.  One can think of it as being in
   -- row, column order.
   --
   type RA8875_GCursor is array (0 .. 31, 0 .. 31) of integer range 0 .. 3
     with -- Convention => Fortran,
--       convention => C,
       Pack;
   type RA8875_GCursorBuffer is array (0 .. 255) of uint8
      with Pack;
   function GCursor_to_buffer is new Ada.Unchecked_Conversion(source => RA8875_GCursor,
                                                              target => RA8875_GCursorBuffer);
\end{lstlisting}

The API is documented below.

\subsubsection{Low Level Methods}
These are primarily intended for supporting the other, higher level routines.
\begin{lstlisting}
procedure setup(self : in out RA8875_record; CS : GPIO.GPIO; screen : SPI_ptr);
\end{lstlisting}
Initialize and configure the RA8875 device.  Use this is no hardware reset GPIO is connected
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $CS$ - The GPIO used as the device chip select.
  \item $screen$ - The SPI bus that the RA8875 is connected to.
\end{itemize}

\begin{lstlisting}
procedure setup(self : in out RA8875_record; CS : GPIO.GPIO;
                RST : GPIO.GPIO; screen : SPI_ptr);
\end{lstlisting}
Initialize and configure the RA8875 device.  Use this if a GPIO is connected to use as a hardware reset.
\begin{itemize}
  \item $self$ - The RA8875 device to configure.
  \item $CS$ - The GPIO used as the device chip select.
  \item $RST$ - The GPIO used as a hardware reset.
  \item $screen$ - The SPI bus that the RA8875 is connected to.
\end{itemize}

\begin{lstlisting}
procedure hwReset(self : in out RA8875_record);
\end{lstlisting}
Send a hardware reset command to the RA8875, if a GPIO has been assigned for hardware reset.  Otherwise, it does nothing.
\begin{itemize}
  \item $self$ - The RA8875 device to reset.
\end{itemize}

\begin{lstlisting}
procedure swReset(self : in out RA8875_record);
\end{lstlisting}
Send a software reset command to the RA8875.  This can be done even if no hardware reset GPIO has been configured.
\begin{itemize}
  \item $self$ - The RA8875 device to reset.
\end{itemize}

\begin{lstlisting}
procedure writeCmd(self : RA8875_record; value : uint8);
\end{lstlisting}
Send a command to the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to send a command to.
  \item $value$ - The command as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
procedure writeData(self : RA8875_record; value : uint8);
\end{lstlisting}
Send data to the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to send data to.
  \item $value$ - The data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
function readStatus(self : RA8875_record) return uint8;
\end{lstlisting}
Read a status value from the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to get status from.
  \item Returns the status as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
function readData(self : RA8875_record) return uint8;
\end{lstlisting}
Read data from the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to get data from.
  \item Returns the data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
procedure writeReg(self : RA8875_record; reg : uint8; value : uint8);
\end{lstlisting}
Writes data to a RA8875 register.
\begin{itemize}
  \item $self$ - The RA8875 device containing the register.
  \item $reg$ - The register number as a \datatype{uint8}.
  \item $value$ - The data as a \datatype{uint8}.
\end{itemize}

\begin{lstlisting}
   function readReg(self : RA8875_record; reg : uint8) return uint8;
\end{lstlisting}
Reads data from a RA8875 register.
\begin{itemize}
  \item $self$ - The RA8875 device containing the register.
  \item $reg$ - The register number as a \datatype{uint8}.
  \item Returns the data as a \datatype{uint8}.
\end{itemize}

\subsubsection{Configuration Methods}
\begin{lstlisting}
procedure configure(self : in out RA8875_record; size : RA8875_sizes);
\end{lstlisting}
Configures the LCD size for use by the RA8875.  Currently only 480x272 and 800x480 are supported and only 800x480 has been tested.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $size$ - The LCD size as a \datatype{RA8875\_sizes}.
\end{itemize}

\begin{lstlisting}
procedure setSleep(self : RA8875_record; state : boolean);
\end{lstlisting}
Sets the sleep state of the RA8875.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - If \constant{True}, puts the RA8875 to sleep and turns the display off.  If \constant{False} just turns the display off.
\end{itemize}

\begin{lstlisting}
procedure setDisplay(self : RA8875_record; state : boolean);
\end{lstlisting}
Turns the display on or off.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - If \constant{True}, turns the display on.  If \constant{False} turns the display off.
\end{itemize}

\begin{lstlisting}
procedure GPIOX(self : RA8875_record; state : boolean);
\end{lstlisting}
Set the state of the GPIOX pin.  This is apparently used in the AdaFruit breakout board, though I'm not sure what it's used for.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the GPIOX pin on or off.
\end{itemize}

\begin{lstlisting}
procedure PWM1config(self : RA8875_record; state : boolean; clock : uint8);
\end{lstlisting}
Configures PWM channel 1.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the PWM Channel 1 to disable (\constant{False}) or enable (\constant{True}).
  \item $clock$ - Sets the clock divide ratio.
\end{itemize}

\begin{lstlisting}
procedure PWM2config(self : RA8875_record; state : boolean; clock : uint8);
\end{lstlisting}
Configures PWM channel 2.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $state$ - Sets the state of the PWM Channel 2 to disable (\constant{False}) or enable (\constant{True}).
  \item $clock$ - Sets the clock divide ratio.
\end{itemize}

\begin{lstlisting}
procedure PWM1out(self : RA8875_record; value : uint8);
\end{lstlisting}
Sets PWM channel 1 duty cycle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $value$ - Sets the duty cycle of PWM Channel 1 in units of $\frac{1}{256}$.
\end{itemize}

\begin{lstlisting}
procedure PWM2out(self : RA8875_record; value : uint8);
\end{lstlisting}
Sets PWM channel 1 duty cycle.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $value$ - Sets the duty cycle of PWM Channel 1 in units of $\frac{1}{256}$.
\end{itemize}

\begin{lstlisting}
procedure setDisplayCtrl(self : RA8875_record; layer : uint8; hdir : uint8;
                         vdir : uint8);
\end{lstlisting}
Sets some of the RA8875 display control parameters.
\begin{itemize}
  \item $self$ - The RA8875 device to control.
  \item $layer$ - 0 For one layer configuration, 128 for two layer configuration.
  \item $hdir$ - 0 For increasing SEG number, 8 for decreasing SEG number.
  \item $vdir$ - 0 For increasing COM number, 4 for decreasing COM number
\end{itemize}

\begin{lstlisting}
   procedure setWriteCtrl0(self : RA8875_record; mode : RA8875_MWCR0_MODE; cursorVisible : boolean;
                           cursorBlink : boolean; writeDir : RA8875_MWCR0_CURDIR; WriteCursorIncr : boolean;
                           ReadCursorIncr : boolean);
\end{lstlisting}
\begin{lstlisting}
   procedure setWriteCtrl1(self : RA8875_record; cursorEnable : RA8875_MWCR1_GCURS_ENABLE;
                           GCursorSelect : RA8875_MWCR1_GCURS_SET; writeDest : RA8875_MWCR1_WRITE_DEST;
                           layer : RA8875_LAYER);
\end{lstlisting}

\subsubsection{Text Methods}
\begin{lstlisting}
   procedure textMode(self : RA8875_record);
   procedure textColor(self : RA8875_record; bg : R5G6B5_color; fg : R5G6B5_color);
   procedure textSetCodePage(self : RA8875_record; page : RA8875_FNCR0_Code_Page);
   procedure textSetAttribute(self : RA8875_record; align : boolean; transparent : boolean;
                              rotate : boolean; h_size : uint8; v_size : uint8);
   procedure textSetLineHeight(self : RA8875_record; size : uint8);
   procedure textSetFontWidth(self : RA8875_record; size : uint8);
   procedure textWrite(self : RA8875_record; str : string);
\end{lstlisting}

\subsubsection{Graphics Methods}
\begin{lstlisting}
   procedure graphicsMode(self : RA8875_record);
   -- Set the color for drawing
   procedure drawColor(self : RA8875_record; color : R5G6B5_color);
   -- Use these procedures to draw in whatever color has already been set
   procedure drawRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16; fill : boolean);
   procedure drawRndRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                         y2 : uint16; rad : uint16; fill : boolean);
   procedure drawLine(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16);
   procedure drawCircle(self : RA8875_record; x : uint16; y : uint16; rad : uint16;
                        fill : boolean);
   procedure drawTriangle(self : RA8875_record; x1 : uint16; y1 : uint16;
                          x2 : uint16; y2 : uint16; x3 : uint16; y3 : uint16;
                          fill : boolean);
   procedure drawEllipse(self : RA8875_record; x : uint16; y : uint16; hRad : uint16;
                        vRad : uint16; fill : boolean);
   procedure drawEllipseSegment(self : RA8875_record; x : uint16; y : uint16; hRad : uint16;
                                vRad : uint16; seg : RA8875_ELLIPSE_PART; fill : boolean);
   -- Use these procedures to specify the color to draw
   procedure drawRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16; color : R5G6B5_color; fill : boolean);
   procedure drawRndRect(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16; rad : uint16; color : R5G6B5_color; fill : boolean);
   procedure drawLine(self : RA8875_record; x1 : uint16; y1 : uint16; x2 : uint16;
                      y2 : uint16; color : R5G6B5_color);
   procedure drawCircle(self : RA8875_record; x : uint16; y : uint16; rad : uint16;
                        color : R5G6B5_color; fill : boolean);
   procedure drawTriangle(self : RA8875_record; x1 : uint16; y1 : uint16;
                          x2 : uint16; y2 : uint16; x3 : uint16; y3 : uint16;
                          color : R5G6B5_color; fill : boolean);
   procedure drawEllipse(self : RA8875_record; x : uint16; y : uint16; hRad : uint16;
                        vRad : uint16; color : R5G6B5_color; fill : boolean);
   procedure drawEllipseSegment(self : RA8875_record; x : uint16; y : uint16; hRad : uint16;
                                vRad : uint16; seg : RA8875_ELLIPSE_PART; color : R5G6B5_color; fill : boolean);
   --
   procedure waitPoll(self : RA8875_record; reg : uint8; flag : uint8);
\end{lstlisting}

\subsubsection{Touch Methods}
\begin{lstlisting}
   procedure enableTouch(self : RA8875_record; state : boolean);
   function checkTouched(self : RA8875_record) return boolean;
   procedure readTouchRaw(self : RA8875_record; x : out uint16; y : out uint16);
   procedure readTouchCal(self : RA8875_record; x : out uint16; y : out uint16);
   procedure touchCalibrate(self : in out RA8875_record);
   procedure setTouchCalibration(self : in out RA8875_record; top : uint16;
                                 bottom : uint16; left : uint16; right : uint16);
   procedure getTouchCalibration(self : RA8875_record; top : out uint16;
                                 bottom : out uint16; left : out uint16; right : out uint16);
\end{lstlisting}

\subsubsection{Region and Layer Methods}
\begin{lstlisting}
   procedure scroll(self : RA8875_record; hStart : uint16; vStart : uint16;
                    hEnd : uint16; vEnd : uint16; hOffset : uint16; vOffset : uint16);
   procedure setActiveWindow(self : RA8875_record; top : uint16; bottom : uint16;
                             left : uint16; right : uint16);
   procedure screenActive(self : RA8875_record);
   procedure setLayers(self : RA8875_record; layer : RA8875_LAYER);
   procedure selectLayer(self : RA8875_record; layer : RA8875_LAYER);
   procedure setLayerSetting0(self : RA8875_record; scroll : RA8875_LTPR0_SCROLL_MODE;
                              float : boolean; display : RA8875_LTPR0_DISP_MODE);
\end{lstlisting}

\subsubsection{Cursor Methods}
\begin{lstlisting}
   procedure setTextCursorPos(self : RA8875_record; x : uint16; y : uint16);
   procedure setGraphCursorColors(self : RA8875_record; color0 : R3G3B2_color;
                                  color1 : R3G3B2_color);
   procedure setGraphCursorPos(self : RA8875_record; x : uint16; y : uint16);
   procedure setGraphCursor(self : RA8875_record; curs : RA8875_MWCR1_GCURS_SET;
                            data : RA8875_GCursor);
   procedure selectGraphCursor(self : RA8875_record; curs : RA8875_MWCR1_GCURS_SET;
                               enable : RA8875_MWCR1_GCURS_ENABLE);
\end{lstlisting}

\subsubsection{Miscellaneous Methods}
\begin{lstlisting}
   procedure fillScreen(self : RA8875_record; color : R5G6B5_color);
\end{lstlisting}

%========================================================
\chapter{Linux API Description}

%--------------------------------------------------------------------------------------------------
\section{Common}

%--------------------------------------------------------------------------------------------------
\section{Raspberry Pi}

%--------------------------------------------------------------------------------------------------
\section{BeagleBone Black}

%========================================================
\chapter{Arduino Due API Description}

%========================================================
\chapter{Other Stuff}
\comment{If there is anything else that should be added, additional chapters may be added as needed.}

%========================================================
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{devices.bib}

\end{document}
