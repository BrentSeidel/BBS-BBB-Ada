\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage{tikz}
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\cli}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
\newcommand{\comment}[1]{{\color{red}{#1}}}
%
\newcommand{\docname}{Users's Manual for \\ Device Interfaces}
%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024, Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\mainmatter
%========================================================
\chapter{Introduction}

%--------------------------------------------------------------------------------------------------
\section{About the Project}
This project provides an interface to hardware available on some Linux based systems and the Arduino Due.  It consists of two main components:  First an abstract set of classes for certain generic hardware items, and second specific classes to interface with the hardware on specific devices.  This separation is done to ease porting of software between different devices.  The two Linux based devices that are currently supported are the Raspberry Pi and the BeagleBone Black.  Other devices may be added by creating a set of specific classes for the device.

%--------------------------------------------------------------------------------------------------
\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How to Obtain}

This collection is currently available on GitHub at \url{https://github.com/BrentSeidel/BBS-BBB-Ada}.  Parts are available through alire via ``\keyword{alr get bbs\_embed\_common}'' and ``\keyword{alr get bbs\_embed\_linux}''

%--------------------------------------------------------------------------------------------------
\section{Dependencies}
\subsection{bbs\_embed\_common}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Integer\_Text\_IO}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions} (used only by lsm303dlhc)
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Text\_IO}
  \item \package{Ada.Unchecked\_Conversion}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed.GPIO}
  \item \package{BBS.embed.i2c}
  \item \package{BBS.embed.log}
  \item \package{BBS.embed.SPI}
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_linux}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Direct\_IO}
  \item \package{Ada.IO\_Exceptions}
  \item \package{Ada.Long\_Integer\_Text\_IO}
  \item \package{Ada.Strings.Fixed}
  \item \package{Ada.Text\_IO}
  \item \package{Interfaces.C}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed}*
  \item \package{BBS.embed.BBB}*
  \item \package{BBS.embed.GPIO}*
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_due}
The Arduino Due requires an appropriate run-time system and cross-compiler.
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Interrupts}
  \item \package{Ada.Interrupts.Names}
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Synchronous\_Task\_Control}
  \item \package{Interfaces}
  \item \package{System}
  \item \package{System.Sam3x8}
\end{itemize}
\subsubsection{SAM3x8e Stuff}
The following SAM3x8e hardware definition packages are used:
\begin{itemize}
  \item \package{SAM3x8e}
  \item \package{SAM3x8e.ADC}
  \item \package{SAM3x8e.PIO}
  \item \package{SAM3x8e.PMC}
  \item \package{SAM3x8e.TWI}
  \item \package{SAM3x8e.UART}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS}*
  \item \package{BBS.embed}*
  \item \package{BBS.embed.due.dev}
  \item \package{BBS.embed.due.serial.int}
  \item \package{BBS.embed.due.serial.polled}
  \item \package{BBS.embed.GPIO.Due}
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
\end{itemize}


%========================================================
\chapter{Usage Instructions}
This chapter contains high-level instructions on using this library in your project.  First, all projects will need to include the \package{bbs\_embed\_common} packages to gain access to the base classes and some device drivers that build on these base classes.  The second step is platform specific, as described below.

%--------------------------------------------------------------------------------------------------
\section{Linux Based Raspberry Pi and BeagleBone Black}
You will need to include the \package{bbs\_embed\_linux} packages in your project.  The \package{BBS.embed.rpi} package contains constants for various device names available on the Raspberry Pi.  The \package{BBS.embed.BBB} package contains constants for various devices names on the BeagleBone Black.  There is a script, \package{init-bbb.sh} for the BeagleBone Black or \package{init-rpi.sh} for the Raspberry Pi that needs to be run to activate some of the devices and set protections on the device files.  The script will need to be run as superuser, using the \cli{sudo} command.  Among other things, it sets protection on the device files so that your software does not need to run as superuser.

%--------------------------------------------------------------------------------------------------
\section{Arduino Due}
This has not been worked on for a while.  To use this, you will need an ARM ELF Ada compiler and a board support package for the Arduino Due.  It did work with a board support package that I'd cobbled together a few generations of gnat ago.  Consider this to be experimental, but it should provide a good start to accessing hardware on the Arduino Due.

%========================================================
\chapter{Common API Description}
Dealing with hardware can be complex, especially if you want your software to be portable.  The various different boards have different devices (or different numbers of devices) available.  Sometimes options are available on one board that are not available on another.

The common library (\package{bbs\_embed\_common} in alire) contains base classes for hardware devices and higher-level drivers for devices that attach to the basic hardware, for example devices that connect via an I2C bus.

%--------------------------------------------------------------------------------------------------
\section{Basic Devices}
The package \package{BBS.embed} defines the following types and functions:
\begin{lstlisting}
type addr7 is mod 2**7
  with size => 7;
type int12 is range -(2**11) .. 2**11 - 1
  with size => 12;
type uint12 is mod 2**12
  with size => 12;
\end{lstlisting}
The \datatype{addr7} is used for addressing devices on an I2C bus.  the \datatype{int12} and \datatype{uint12} are used for the return values from typical analog to digital converters and anywhere else a 12 bit number is needed.
\begin{lstlisting}
function uint12_to_int12 is
  new Ada.Unchecked_Conversion(source => uint12, target => int12);
\end{lstlisting}
This is used to convert from unsigned to signed 12 bit integers.  Should the reverse conversion be needed, it would be easy enough to add it here.
\begin{lstlisting}
function highByte(x : uint16) return uint8 is
     (uint8(x / 2**8));
function lowByte(x : uint16) return uint8 is
      (uint8(x and 16#FF#));
\end{lstlisting}
These are used to extract the MSB and LST from \datatype{uint16} values.

\subsection{Analog Inputs}
Analog inputs have one common routine to read the value.  Everything else is implementation dependent.
\begin{lstlisting}
function get(self : AIN_record) return uint12 is abstract;
\end{lstlisting}
Read the value of the specified analog to digital converter.
\begin{itemize}
  \item $self$ - The object for the analog input device.
  \item Returns the 12-bit value from the analog to digital converter.
\end{itemize}

\subsection{General-Purpose Input/Output (GPIO)}
A GPIO is a device capable of reading or writing a single bit.  The physical characteristics are hardware dependent.  Some device specific routines may be needed to convert between input and output.
\begin{lstlisting}
procedure set(self : GPIO_record; value : bit) is abstract;
\end{lstlisting}
Sets the output value of a GPIO device.  The effect if the device is set to input is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item $value$ - The value to write to the GPIO device.
\end{itemize}
\begin{lstlisting}
function get(self : GPIO_record) return bit is abstract;
\end{lstlisting}
Reads the value of a GPIO device.  The value returned if the device is set to output is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item Returns the value read from the GPIO device.
\end{itemize}

\subsection{I2C Bus}
An I2C bus can interface with a number of devices on the bus.  It operates with the CPU being the master and the addressed device responding.  The basic I2C bus uses 7 bit addressing for devices and operates at 100kHz.  Any other options (10 bit addressing or higher speeds would be device specific, if supported).

The \package{BBS.embed.i2c} defines some datatypes.  The ones for external use are:
\begin{itemize}
  \item \datatype{err\_code} is an enumeration of error statuses that can be returned.  The possible values are \datatype{none}, \datatype{nack}, \datatype{ovre}, \datatype{invalid\_addr}, and \datatype{failed}.  In most cases you'll just want to compare the returned error to \datatype{none}.
  \item \datatype{buff\_index} is an \datatype{Integer} index into a buffer with a range of 0 .. 127.
  \item \datatype{buffer} is an array of \datatype{uint8} and bounds of \datatype{buff\_index}.  It is used for buffering data for I2C bus transfers.
\end{itemize}

The following routines are used for communicating with devices on the I2C bus.  Note that there is no standard about whether multibyte data should be transferred LSB first or MSB first (I've even seen devices that use both depending on which data you're getting).  Routines are provided for MSB first (m1 routines) or MSB second (m2 routines) for 16 bit transfers.  For longer transfers, use the block transfer routines and decode the data yourself.  The 8 and 16 bit routines cover most of the cases.
\begin{lstlisting}
function read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
              error : out err_code) return uint8 is (0);
\end{lstlisting}
Read a single byte of data from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred first from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred second from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
procedure read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
               size : buff_index; error : out err_code) is null;
\end{lstlisting}
Reads a block of data into the interface record's buffer.  The user's code will need to extract the data from that buffer and process it as needed.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                data : uint8; error : out err_code) is null;
\end{lstlisting}
Write a single byte of data to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred first to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred second to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                size : buff_index; error : out err_code) is null;
\end{lstlisting}
Send the specified number of bytes in the interface record's buffer to the specified device and register.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}
In most cases these routines should only be used when writing a driver for an I2C device.

\subsection{Logging}
\comment{This is only for debugging purposes.  Should say something here briefly.}

\subsection{SPI Bus}
The exposed interface for the SPI bus is much simpler than for the I2C bus.  If needed, more routines may be added here, but this hasn't been developed as much as the I2C bus interface.
\begin{lstlisting}
procedure set(self : SPI_record; value : uint8) is abstract;
\end{lstlisting}
Writes a byte to the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item $data$ - The data to write.
\end{itemize}
\begin{lstlisting}
function get(self : SPI_record) return uint8 is abstract;
\end{lstlisting}
Reads a byte from the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item Returns the byte read from the bus.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{Higher-Level Device Drivers}
These higher-level device drivers build on the lower-level devices.  Typically these are devices that attach to a databus.

\subsection{\package{BBS.embed.gpio.tb6612}}
This is a driver for the Toshiba TB6612 dual DC motor controller \cite{TB6612}.  The device driver is designed to sequence the output to drive a stepper motor, or it can control two DC motors separately.  It requires four GPIO output pins.

\begin{lstlisting}
procedure init(self : in out TB6612_record; pin_a : BBS.embed.GPIO.GPIO;
               pin_b : BBS.embed.GPIO.GPIO; pin_c : BBS.embed.GPIO.GPIO;
               pin_d : BBS.embed.GPIO.GPIO);
\end{lstlisting}
Initialize the TB6612 driver with the 4 GPIO devices.
\begin{itemize}
  \item $self$ - The TB6612 device to initialize.
  \item $pin\_a$ - The first GPIO pin.
  \item $pin\_b$ - The second GPIO pin.
  \item $pin\_c$ - The third GPIO pin.
  \item $pin\_d$ - The fourth GPIO pin.
\end{itemize}
\begin{lstlisting}
procedure set_delay(self : in out TB6612_record; wait_time : Natural);
\end{lstlisting}
Set a time delay between steps to use when stepping the motor a number of steps.  If not needed, it can be set to zero.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $wait\_time$ - The time delay between steps in mS.
\end{itemize}
\begin{lstlisting}
procedure step(self : in out TB6612_record; steps : Integer);
\end{lstlisting}
Move the stepper motor a specified number of steps.  A negative number will move in the opposite direction as a positive number.  Zero steps will do nothing.  If no delay has been specified, a default of 5mS between steps will be used.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $steps$ - The number of steps to move the motor.
\end{itemize}
\begin{lstlisting}
procedure stepper_off(self : in out TB6612_record);
\end{lstlisting}
De-energize the coils for a stepper motor (or both DC motors).
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
\end{itemize}
\begin{lstlisting}
procedure set_bridge_a(self : in out TB6612_record; value : Integer);
procedure set_bridge_b(self : in out TB6612_record; value : Integer);
\end{lstlisting}
Each of the two H-bridges can be controlled separately.  This would allow two DC motors to be driven.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $value$ - A value of zero sets the bridge off.  A positive value sets the polarity in one direction.  A negative value sets the polarity in the opposite direction.
\end{itemize}

Note that polarities are not specified as they depend on how the hardware is wired.

\subsection{\package{BBS.embed.I2C.ADS1015}}
This is a driver for the Texas Instruments ADS1015 4 channel analog to digital convertor that attaches to an I2C bus \cite{ADS1015}.  This converter has a wide variety of configuration options.  Refer to the datasheet for details.  A number of constants have been defined to support the various configuration options (see Tables \ref{tbl:ADS1015mux}, \ref{tbl:ADS1015PGA}. \ref{tbl:ADS1015DRC}, and \ref{tbl:ADS1015CompQ}).

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Mux Mode Configuration \\
    \hline
    \constant{mux\_a0\_a1} & Difference between AIN0 and AIN1 (default) \\
    \constant{mux\_a0\_a3} & Difference between AIN0 and AIN3 \\
    \constant{mux\_a1\_a3} & Difference between AIN1 and AIN3 \\
    \constant{mux\_a2\_a3} & Difference between AIN2 and AIN3 \\
    \constant{mux\_a0\_gnd} & Single ended AIN0 value \\
    \constant{mux\_a1\_gnd} & Single ended AIN1 value \\
    \constant{mux\_a2\_gnd} & Single ended AIN2 value \\
    \constant{mux\_a3\_gnd} & Single ended AIN3 value \\
  \end{tabular}
  \caption{Constants for ADS1015 Mux Mode Configuration}
  \label{tbl:ADS1015mux}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & PGA Configuration \\
    \hline
    \constant{pga\_6\_144} & Full scale voltage is 6.144V \\
    \constant{pga\_4\_096} & Full scale voltage is 4.096V \\
    \constant{pga\_2\_048} & Full scale voltage is 2.048V (default) \\
    \constant{pga\_1\_024} & Full scale voltage is 1.024V \\
    \constant{pga\_0\_512} & Full scale voltage is 0.512V \\
    \constant{pga\_0\_256} & Full scale voltage is 0.256V \\
  \end{tabular}
  \caption{Constants for ADS1015 Programmable Gain Amplifier Configuration}
  \label{tbl:ADS1015PGA}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Data Rate in Samples per Second (S/S) \\
    \hline
    \constant{dr\_0128} & Data rate is 128S/S \\
    \constant{dr\_0250} & Data rate is 250S/S \\
    \constant{dr\_0490} & Data rate is 490S/S \\
    \constant{dr\_0920} & Data rate is 920S/S \\
    \constant{dr\_1600} & Data rate is 1600S/S (default) \\
    \constant{dr\_2400} & Data rate is 2400S/S \\
    \constant{dr\_3300} & Data rate is 3300S/S \\
  \end{tabular}
  \caption{Constants for ADS1015 Data Rate Configuration}
  \label{tbl:ADS1015DRC}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Comparator Queue Configuration \\
    \hline
    \constant{comp\_que\_1} & Assert after one conversion \\
    \constant{comp\_que\_2} & Assert after two conversions \\
    \constant{comp\_que\_3} & Assert after three conversion \\
    \constant{comp\_que\_d} & Disable comparator (default) \\
  \end{tabular}
  \caption{Constants for ADS1015 Comparator Queue Configuration}
  \label{tbl:ADS1015CompQ}
\end{center}
\end{table}

There are some additional configuration parameters that don't have constants defined.  These just have values of 0 or 1.  See Table \ref{tbl:ADS1015Misc}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Value & Conversion Mode \\
    0 & Continuous conversion mode \\
    1 & Power-down single-shot mode (default) \\
    \hline
    Value & Comparator Mode \\
    0 & Traditional, with hysteresis (default) \\
    1 & Window comparator \\
    \hline
    Value & Comparator Polarity \\
    0 & Active low (default) \\
    1 & Active high \\
    \hline
    Value & Comparator Latching \\
    0 & Non-latching comparator (default) \\
    1 & Latching comparator \\
  \end{tabular}
  \caption{Constants for ADS1015 Miscellaneous Configuration}
  \label{tbl:ADS1015Misc}
\end{center}
\end{table}

The datatype \datatype{ADS1015\_config} is defined as a record containing the configuration values.  It has the following fields:
\begin{itemize}
    \item \datatype{os} - Operational status, used to start a conversion if in single shot mode.  Don't use when setting configuration.
    \item \datatype{mux} - The mux mode (see Table \ref{tbl:ADS1015mux}).
    \item \datatype{pga} - The programmable gain type (see Table \ref{tbl:ADS1015PGA}).
    \item \datatype{mode} - Conversion mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{dr} - The data rate (see Table \ref{tbl:ADS1015DRC}).
    \item \datatype{comp\_mode} - The comparator mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_pol} - The comparator polarity (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_lat} - The comparator latching (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_que} - The comparator queue configuration  (see Table \ref{tbl:ADS1015CompQ}).
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Initializes the device to the default configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; config : ADS1015_config; error : out err_code);
\end{lstlisting}
Initialize the device using the specified configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure change_config(self : in out ADS1015_record;
                        config : ADS1015_config; error : out err_code);
\end{lstlisting}
Changes the device configuration to new values
\begin{itemize}
  \item $self$ - The device to modify.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_mux(self : in out ADS1015_record;
                  mux : mux_mode_type; error : out err_code);
\end{lstlisting}
Changes only the mux mode configuration.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $mux$ - The new mux mode configuration value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_gain(self : in out ADS1015_record;
                  gain : pga_type; error : out err_code);
\end{lstlisting}
Changes only the converter gain value.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $gain$ - The new gain value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_continuous(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}
\begin{lstlisting}
procedure set_1shot(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in single shot mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Start a conversion when in single shot mode.  No effect in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
function conversion_done(self : in out ADS1015_record; error : out err_code)
    return Boolean;
\end{lstlisting}
Checks if conversion is in progress.  Will always return \constant{False} (conversion in progress) while in continuous mode.  Returns \constant{True} when no conversion is in progress.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns a conversion in progress flag.
\end{itemize}

\begin{lstlisting}
function get_result(self : in out ADS1015_record; error : out err_code)
    return uint12;
\end{lstlisting}
Returns the conversion value.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns the conversion value
\end{itemize}

\subsection{\package{BBS.embed.i2c.BME280}}
This is a driver for the Bosch BME280 temperature, pressure, and humidity sensor that attaches to an I2C bus \cite{BME280}.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BME280 sensor and is intended for use in the \function{configure} call.

\begin{lstlisting}
procedure configure(self : in out BME280_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure a BME280 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BME280 device to configure.
  \item $port$ - The I2C bus object that the BME280 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}
\begin{lstlisting}
procedure start_conversion(self : BME280_record; error : out err_code);
\end{lstlisting}
Instruct the BME280 to start converting temperature, pressure, and humidity readings.  These are converted at the same time.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}
\begin{lstlisting}
function data_ready(self : BME280_record; error : out err_code) return boolean;
\end{lstlisting}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}
\begin{lstlisting}
procedure read_data(self : in out BME280_record; error : out err_code);
\end{lstlisting}
Instructs the BME280 to read the converted temperature, pressure, and humidity values into BME280 object and compute calibrated values.  There is less overhead to read all three at once.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}
\begin{lstlisting}
procedure get_raw(self : BME280_record; raw_temp : out uint32;
                  raw_press : out uint32; raw_hum : out uint32);
\end{lstlisting}
Return the raw, uncompensated values after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $raw\_temp$ - The raw temperature value.
  \item $raw\_press$ - The raw pressure value.
  \item $raw\_hum$ - The raw humidity value.
\end{itemize}
\begin{lstlisting}
function get_t_fine(self : BME280_record) return int32;
\end{lstlisting}
Returns the \package{t\_fine} value after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the \package{t\_fine} value.
\end{itemize}
\begin{lstlisting}
function get_temp(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated temperature value as an integer.  The LSB unit is 0.01\degree{}C.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of 0.01\degree{}C.
\end{itemize}
\begin{lstlisting}
function get_temp(self : BME280_record) return BBS.units.temp_c;
function get_temp(self : BME280_record) return BBS.units.temp_f;
function get_temp(self : BME280_record) return BBS.units.temp_k;
\end{lstlisting}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}
\begin{lstlisting}
function get_press(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated pressure value as an integer.  The LSB unit is $\frac{1}{256}$Pa.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of $\frac{1}{256}$Pa.
\end{itemize}
\begin{lstlisting}
function get_press(self : BME280_record) return BBS.units.press_p;
function get_press(self : BME280_record) return BBS.units.press_mb;
function get_press(self : BME280_record) return BBS.units.press_atm;
function get_press(self : BME280_record) return BBS.units.press_inHg;
\end{lstlisting}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}
\begin{lstlisting}
function get_hum(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated relative humidity as an integer.  The LSB unit is $\frac{1}{1024}$\% humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity in units of $\frac{1}{1024}$\% humidity.
\end{itemize}
\begin{lstlisting}
function get_hum(self : BME280_record) return float;
\end{lstlisting}
Returns the relative humidity as a percentage relative humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity as a percentage relative humidity.
\end{itemize}

%========================================================
\chapter{Linux API Description}

%--------------------------------------------------------------------------------------------------
\section{Raspberry Pi}

%--------------------------------------------------------------------------------------------------
\section{BeagleBone Black}

%========================================================
\chapter{Arduino Due API Description}

%========================================================
\chapter{Other Stuff}
\comment{If there is anything else that should be added, additional chapters may be added as needed.}

%========================================================
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{devices.bib}

\end{document}
