\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage{tikz}
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\cli}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
\newcommand{\comment}[1]{{\color{red}{#1}}}
%
\newcommand{\docname}{Users's Manual for \\ Device Interfaces}
%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024, Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\listoftables

\mainmatter
%========================================================
\chapter{Introduction}

%--------------------------------------------------------------------------------------------------
\section{About the Project}
This project provides an interface to hardware available on some Linux based systems and the Arduino Due.  It consists of two main components:  First an abstract set of classes for certain generic hardware items, and second specific classes to interface with the hardware on specific devices.  This separation is done to ease porting of software between different devices.  The two Linux based devices that are currently supported are the Raspberry Pi and the BeagleBone Black.  Other devices may be added by creating a set of specific classes for the device.

%--------------------------------------------------------------------------------------------------
\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How to Obtain}

This collection is currently available on GitHub at \url{https://github.com/BrentSeidel/BBS-BBB-Ada}.  Parts are available through alire via ``\keyword{alr get bbs\_embed\_common}'' and ``\keyword{alr get bbs\_embed\_linux}''

%--------------------------------------------------------------------------------------------------
\section{Dependencies}
\subsection{bbs\_embed\_common}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Integer\_Text\_IO}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions} (used only by lsm303dlhc)
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Text\_IO}
  \item \package{Ada.Unchecked\_Conversion}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed.GPIO}
  \item \package{BBS.embed.i2c}
  \item \package{BBS.embed.log}
  \item \package{BBS.embed.SPI}
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_linux}
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Direct\_IO}
  \item \package{Ada.IO\_Exceptions}
  \item \package{Ada.Long\_Integer\_Text\_IO}
  \item \package{Ada.Strings.Fixed}
  \item \package{Ada.Text\_IO}
  \item \package{Interfaces.C}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS.embed}*
  \item \package{BBS.embed.BBB}*
  \item \package{BBS.embed.GPIO}*
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
  \item \package{BBS.units}*
\end{itemize}

\subsection{bbs\_embed\_due}
The Arduino Due requires an appropriate run-time system and cross-compiler.
\subsubsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Interrupts}
  \item \package{Ada.Interrupts.Names}
  \item \package{Ada.Real\_Time}
  \item \package{Ada.Synchronous\_Task\_Control}
  \item \package{Interfaces}
  \item \package{System}
  \item \package{System.Sam3x8}
\end{itemize}
\subsubsection{SAM3x8e Stuff}
The following SAM3x8e hardware definition packages are used:
\begin{itemize}
  \item \package{SAM3x8e}
  \item \package{SAM3x8e.ADC}
  \item \package{SAM3x8e.PIO}
  \item \package{SAM3x8e.PMC}
  \item \package{SAM3x8e.TWI}
  \item \package{SAM3x8e.UART}
\end{itemize}
\subsubsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} and through alire via ``\keyword{alr get bbs}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS}*
  \item \package{BBS.embed}*
  \item \package{BBS.embed.due.dev}
  \item \package{BBS.embed.due.serial.int}
  \item \package{BBS.embed.due.serial.polled}
  \item \package{BBS.embed.GPIO.Due}
  \item \package{BBS.embed.log}*
  \item \package{BBS.embed.SPI}*
\end{itemize}


%========================================================
\chapter{Usage Instructions}
This chapter contains high-level instructions on using this library in your project.  First, all projects will need to include the \package{bbs\_embed\_common} packages to gain access to the base classes and some device drivers that build on these base classes.  The second step is platform specific, as described below.

%--------------------------------------------------------------------------------------------------
\section{Linux Based Raspberry Pi and BeagleBone Black}
You will need to include the \package{bbs\_embed\_linux} packages in your project.  The \package{BBS.embed.rpi} package contains constants for various device names available on the Raspberry Pi.  The \package{BBS.embed.BBB} package contains constants for various devices names on the BeagleBone Black.  There is a script, \package{init-bbb.sh} for the BeagleBone Black or \package{init-rpi.sh} for the Raspberry Pi that needs to be run to activate some of the devices and set protections on the device files.  The script will need to be run as superuser, using the \cli{sudo} command.  Among other things, it sets protection on the device files so that your software does not need to run as superuser.

%--------------------------------------------------------------------------------------------------
\section{Arduino Due}
This has not been worked on for a while.  To use this, you will need an ARM ELF Ada compiler and a board support package for the Arduino Due.  It did work with a board support package that I'd cobbled together a few generations of gnat ago.  Consider this to be experimental, but it should provide a good start to accessing hardware on the Arduino Due.

%========================================================
\chapter{Common API Description}
Dealing with hardware can be complex, especially if you want your software to be portable.  The various different boards have different devices (or different numbers of devices) available.  Sometimes options are available on one board that are not available on another.

The common library (\package{bbs\_embed\_common} in alire) contains base classes for hardware devices and higher-level drivers for devices that attach to the basic hardware, for example devices that connect via an I2C bus.

%--------------------------------------------------------------------------------------------------
\section{Basic Devices}
The package \package{BBS.embed} defines the following types and functions:
\begin{lstlisting}
type addr7 is mod 2**7
  with size => 7;
type int12 is range -(2**11) .. 2**11 - 1
  with size => 12;
type uint12 is mod 2**12
  with size => 12;
\end{lstlisting}
The \datatype{addr7} is used for addressing devices on an I2C bus.  the \datatype{int12} and \datatype{uint12} are used for the return values from typical analog to digital converters and anywhere else a 12 bit number is needed.
\begin{lstlisting}
function uint12_to_int12 is
  new Ada.Unchecked_Conversion(source => uint12, target => int12);
\end{lstlisting}
This is used to convert from unsigned to signed 12 bit integers.  Should the reverse conversion be needed, it would be easy enough to add it here.
\begin{lstlisting}
function highByte(x : uint16) return uint8 is
     (uint8(x / 2**8));
function lowByte(x : uint16) return uint8 is
      (uint8(x and 16#FF#));
\end{lstlisting}
These are used to extract the MSB and LST from \datatype{uint16} values.

\subsection{Analog Inputs}
Analog inputs have one common routine to read the value.  Everything else is implementation dependent.
\begin{lstlisting}
function get(self : AIN_record) return uint12 is abstract;
\end{lstlisting}
Read the value of the specified analog to digital converter.
\begin{itemize}
  \item $self$ - The object for the analog input device.
  \item Returns the 12-bit value from the analog to digital converter.
\end{itemize}

\subsection{General-Purpose Input/Output (GPIO)}
A GPIO is a device capable of reading or writing a single bit.  The physical characteristics are hardware dependent.  Some device specific routines may be needed to convert between input and output.
\begin{lstlisting}
procedure set(self : GPIO_record; value : bit) is abstract;
\end{lstlisting}
Sets the output value of a GPIO device.  The effect if the device is set to input is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item $value$ - The value to write to the GPIO device.
\end{itemize}
\begin{lstlisting}
function get(self : GPIO_record) return bit is abstract;
\end{lstlisting}
Reads the value of a GPIO device.  The value returned if the device is set to output is device specific.
\begin{itemize}
  \item $self$ - The object for the GPIO device.
  \item Returns the value read from the GPIO device.
\end{itemize}

\subsection{I2C Bus}
An I2C bus can interface with a number of devices on the bus.  It operates with the CPU being the master and the addressed device responding.  The basic I2C bus uses 7 bit addressing for devices and operates at 100kHz.  Any other options (10 bit addressing or higher speeds would be device specific, if supported).

The \package{BBS.embed.i2c} defines some datatypes.  The ones for external use are:
\begin{itemize}
  \item \datatype{err\_code} is an enumeration of error statuses that can be returned.  The possible values are \datatype{none}, \datatype{nack}, \datatype{ovre}, \datatype{invalid\_addr}, and \datatype{failed}.  In most cases you'll just want to compare the returned error to \datatype{none}.
  \item \datatype{buff\_index} is an \datatype{Integer} index into a buffer with a range of 0 .. 127.
  \item \datatype{buffer} is an array of \datatype{uint8} and bounds of \datatype{buff\_index}.  It is used for buffering data for I2C bus transfers.
\end{itemize}

The following routines are used for communicating with devices on the I2C bus.  Note that there is no standard about whether multibyte data should be transferred LSB first or MSB first (I've even seen devices that use both depending on which data you're getting).  Routines are provided for MSB first (m1 routines) or MSB second (m2 routines) for 16 bit transfers.  For longer transfers, use the block transfer routines and decode the data yourself.  The 8 and 16 bit routines cover most of the cases.
\begin{lstlisting}
function read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
              error : out err_code) return uint8 is (0);
\end{lstlisting}
Read a single byte of data from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred first from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
function readm2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                error : out err_code) return uint16 is (0);
\end{lstlisting}
Read two bytes of data with MSB transferred second from the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $error$ - The error code from the transaction.
  \item Returns the register contents.
\end{itemize}

\begin{lstlisting}
procedure read(self : in out i2c_interface_record; addr : addr7; reg : uint8;
               size : buff_index; error : out err_code) is null;
\end{lstlisting}
Reads a block of data into the interface record's buffer.  The user's code will need to extract the data from that buffer and process it as needed.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                data : uint8; error : out err_code) is null;
\end{lstlisting}
Write a single byte of data to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem1(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred first to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure writem2(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                  data : uint16; error : out err_code) is null;
\end{lstlisting}
Writes two bytes of data with the MSB transferred second to the specified register in the specified device.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $data$ - The data to write.
  \item $error$ - The error code from the transaction.
\end{itemize}

\begin{lstlisting}
procedure write(self : in out i2c_interface_record; addr : addr7; reg : uint8;
                size : buff_index; error : out err_code) is null;
\end{lstlisting}
Send the specified number of bytes in the interface record's buffer to the specified device and register.
\begin{itemize}
  \item $self$ - The I2C interface device to use for communication.
  \item $addr7$ - The 7 bit address of the device to communicate with.
  \item $reg$ - The register address in the device.
  \item $size$ - The number of bytes to transfer.
  \item $error$ - The error code from the transaction.
\end{itemize}
In most cases these routines should only be used when writing a driver for an I2C device.

\subsection{Logging}
\comment{This is only for debugging purposes.  Should say something here briefly.}

\subsection{SPI Bus}
The exposed interface for the SPI bus is much simpler than for the I2C bus.  If needed, more routines may be added here, but this hasn't been developed as much as the I2C bus interface.
\begin{lstlisting}
procedure set(self : SPI_record; value : uint8) is abstract;
\end{lstlisting}
Writes a byte to the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item $data$ - The data to write.
\end{itemize}
\begin{lstlisting}
function get(self : SPI_record) return uint8 is abstract;
\end{lstlisting}
Reads a byte from the SPI bus.
\begin{itemize}
  \item $self$ - The SPI interface device to use for communication.
  \item Returns the byte read from the bus.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{Higher-Level Device Drivers}
These higher-level device drivers build on the lower-level devices.  Typically these are devices that attach to a databus.

\subsection{\package{BBS.embed.gpio.tb6612}}
This is a driver for the Toshiba TB6612 dual DC motor controller \cite{TB6612}.  The device driver is designed to sequence the output to drive a stepper motor, or it can control two DC motors separately.  It requires four GPIO output pins.

\begin{lstlisting}
procedure init(self : in out TB6612_record; pin_a : BBS.embed.GPIO.GPIO;
               pin_b : BBS.embed.GPIO.GPIO; pin_c : BBS.embed.GPIO.GPIO;
               pin_d : BBS.embed.GPIO.GPIO);
\end{lstlisting}
Initialize the TB6612 driver with the 4 GPIO devices.
\begin{itemize}
  \item $self$ - The TB6612 device to initialize.
  \item $pin\_a$ - The first GPIO pin.
  \item $pin\_b$ - The second GPIO pin.
  \item $pin\_c$ - The third GPIO pin.
  \item $pin\_d$ - The fourth GPIO pin.
\end{itemize}
\begin{lstlisting}
procedure set_delay(self : in out TB6612_record; wait_time : Natural);
\end{lstlisting}
Set a time delay between steps to use when stepping the motor a number of steps.  If not needed, it can be set to zero.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $wait\_time$ - The time delay between steps in mS.
\end{itemize}
\begin{lstlisting}
procedure step(self : in out TB6612_record; steps : Integer);
\end{lstlisting}
Move the stepper motor a specified number of steps.  A negative number will move in the opposite direction as a positive number.  Zero steps will do nothing.  If no delay has been specified, a default of 5mS between steps will be used.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $steps$ - The number of steps to move the motor.
\end{itemize}
\begin{lstlisting}
procedure stepper_off(self : in out TB6612_record);
\end{lstlisting}
De-energize the coils for a stepper motor (or both DC motors).
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
\end{itemize}
\begin{lstlisting}
procedure set_bridge_a(self : in out TB6612_record; value : Integer);
procedure set_bridge_b(self : in out TB6612_record; value : Integer);
\end{lstlisting}
Each of the two H-bridges can be controlled separately.  This would allow two DC motors to be driven.
\begin{itemize}
  \item $self$ - The TB6612 device to modify.
  \item $value$ - A value of zero sets the bridge off.  A positive value sets the polarity in one direction.  A negative value sets the polarity in the opposite direction.
\end{itemize}

Note that polarities are not specified as they depend on how the hardware is wired.

\subsection{\package{BBS.embed.I2C.ADS1015}}
This is a driver for the Texas Instruments ADS1015 4 channel analog to digital convertor that attaches to an I2C bus \cite{ADS1015}.  This converter has a wide variety of configuration options.  Refer to the datasheet for details.  A number of constants have been defined to support the various configuration options (see Tables \ref{tbl:ADS1015mux}, \ref{tbl:ADS1015PGA}. \ref{tbl:ADS1015DRC}, and \ref{tbl:ADS1015CompQ}).

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Mux Mode Configuration \\
    \hline
    \constant{mux\_a0\_a1} & Difference between AIN0 and AIN1 (default) \\
    \constant{mux\_a0\_a3} & Difference between AIN0 and AIN3 \\
    \constant{mux\_a1\_a3} & Difference between AIN1 and AIN3 \\
    \constant{mux\_a2\_a3} & Difference between AIN2 and AIN3 \\
    \constant{mux\_a0\_gnd} & Single ended AIN0 value \\
    \constant{mux\_a1\_gnd} & Single ended AIN1 value \\
    \constant{mux\_a2\_gnd} & Single ended AIN2 value \\
    \constant{mux\_a3\_gnd} & Single ended AIN3 value \\
  \end{tabular}
  \caption{Constants for ADS1015 Mux Mode Configuration}
  \label{tbl:ADS1015mux}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & PGA Configuration \\
    \hline
    \constant{pga\_6\_144} & Full scale voltage is 6.144V \\
    \constant{pga\_4\_096} & Full scale voltage is 4.096V \\
    \constant{pga\_2\_048} & Full scale voltage is 2.048V (default) \\
    \constant{pga\_1\_024} & Full scale voltage is 1.024V \\
    \constant{pga\_0\_512} & Full scale voltage is 0.512V \\
    \constant{pga\_0\_256} & Full scale voltage is 0.256V \\
  \end{tabular}
  \caption{Constants for ADS1015 Programmable Gain Amplifier Configuration}
  \label{tbl:ADS1015PGA}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Data Rate in Samples per Second (S/S) \\
    \hline
    \constant{dr\_0128} & Data rate is 128S/S \\
    \constant{dr\_0250} & Data rate is 250S/S \\
    \constant{dr\_0490} & Data rate is 490S/S \\
    \constant{dr\_0920} & Data rate is 920S/S \\
    \constant{dr\_1600} & Data rate is 1600S/S (default) \\
    \constant{dr\_2400} & Data rate is 2400S/S \\
    \constant{dr\_3300} & Data rate is 3300S/S \\
  \end{tabular}
  \caption{Constants for ADS1015 Data Rate Configuration}
  \label{tbl:ADS1015DRC}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Comparator Queue Configuration \\
    \hline
    \constant{comp\_que\_1} & Assert after one conversion \\
    \constant{comp\_que\_2} & Assert after two conversions \\
    \constant{comp\_que\_3} & Assert after three conversion \\
    \constant{comp\_que\_d} & Disable comparator (default) \\
  \end{tabular}
  \caption{Constants for ADS1015 Comparator Queue Configuration}
  \label{tbl:ADS1015CompQ}
\end{center}
\end{table}

There are some additional configuration parameters that don't have constants defined.  These just have values of 0 or 1.  See Table \ref{tbl:ADS1015Misc}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Value & Conversion Mode \\
    0 & Continuous conversion mode \\
    1 & Power-down single-shot mode (default) \\
    \hline
    Value & Comparator Mode \\
    0 & Traditional, with hysteresis (default) \\
    1 & Window comparator \\
    \hline
    Value & Comparator Polarity \\
    0 & Active low (default) \\
    1 & Active high \\
    \hline
    Value & Comparator Latching \\
    0 & Non-latching comparator (default) \\
    1 & Latching comparator \\
  \end{tabular}
  \caption{Constants for ADS1015 Miscellaneous Configuration}
  \label{tbl:ADS1015Misc}
\end{center}
\end{table}

The datatype \datatype{ADS1015\_config} is defined as a record containing the configuration values.  It has the following fields:
\begin{itemize}
    \item \datatype{os} - Operational status, used to start a conversion if in single shot mode.  Don't use when setting configuration.
    \item \datatype{mux} - The mux mode (see Table \ref{tbl:ADS1015mux}).
    \item \datatype{pga} - The programmable gain type (see Table \ref{tbl:ADS1015PGA}).
    \item \datatype{mode} - Conversion mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{dr} - The data rate (see Table \ref{tbl:ADS1015DRC}).
    \item \datatype{comp\_mode} - The comparator mode (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_pol} - The comparator polarity (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_lat} - The comparator latching (see Table \ref{tbl:ADS1015Misc}).
    \item \datatype{comp\_que} - The comparator queue configuration  (see Table \ref{tbl:ADS1015CompQ}).
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Initializes the device to the default configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out ADS1015_record; port : i2c_interface;
                    addr : addr7; config : ADS1015_config; error : out err_code);
\end{lstlisting}
Initialize the device using the specified configuration.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $port$ - The I2C interface that the device is connected to.
  \item $addr$ - The I2C address of the device.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure change_config(self : in out ADS1015_record;
                        config : ADS1015_config; error : out err_code);
\end{lstlisting}
Changes the device configuration to new values
\begin{itemize}
  \item $self$ - The device to modify.
  \item $config$ - A configuration record containing the desired configuration
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_mux(self : in out ADS1015_record;
                  mux : mux_mode_type; error : out err_code);
\end{lstlisting}
Changes only the mux mode configuration.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $mux$ - The new mux mode configuration value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_gain(self : in out ADS1015_record;
                  gain : pga_type; error : out err_code);
\end{lstlisting}
Changes only the converter gain value.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $gain$ - The new gain value.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure set_continuous(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}
\begin{lstlisting}
procedure set_1shot(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Sets the converter to operate in single shot mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out ADS1015_record; error : out err_code);
\end{lstlisting}
Start a conversion when in single shot mode.  No effect in continuous mode.
\begin{itemize}
  \item $self$ - The device to modify.
  \item $error$ - The I2C error code.
\end{itemize}

\begin{lstlisting}
function conversion_done(self : in out ADS1015_record; error : out err_code)
    return Boolean;
\end{lstlisting}
Checks if conversion is in progress.  Will always return \constant{False} (conversion in progress) while in continuous mode.  Returns \constant{True} when no conversion is in progress.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns a conversion in progress flag.
\end{itemize}

\begin{lstlisting}
function get_result(self : in out ADS1015_record; error : out err_code)
    return uint12;
\end{lstlisting}
Returns the conversion value.
\begin{itemize}
  \item $self$ - The device to initialize.
  \item $error$ - The I2C error code.
  \item Returns the conversion value
\end{itemize}

\subsection{\package{BBS.embed.i2c.BME280}}
This is a driver for the Bosch BME280 temperature, pressure, and humidity sensor that attaches to an I2C bus \cite{BME280}.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BME280 sensor and is intended for use in the \function{configure} call.

\begin{lstlisting}
procedure configure(self : in out BME280_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure a BME280 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BME280 device to configure.
  \item $port$ - The I2C bus object that the BME280 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : BME280_record; error : out err_code);
\end{lstlisting}
Instruct the BME280 to start converting temperature, pressure, and humidity readings.  These are converted at the same time.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BME280_record; error : out err_code) return boolean;
\end{lstlisting}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
procedure read_data(self : in out BME280_record; error : out err_code);
\end{lstlisting}
Instructs the BME280 to read the converted temperature, pressure, and humidity values into BME280 object and compute calibrated values.  There is less overhead to read all three at once.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure get_raw(self : BME280_record; raw_temp : out uint32;
                  raw_press : out uint32; raw_hum : out uint32);
\end{lstlisting}
Return the raw, uncompensated values after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item $raw\_temp$ - The raw temperature value.
  \item $raw\_press$ - The raw pressure value.
  \item $raw\_hum$ - The raw humidity value.
\end{itemize}

\begin{lstlisting}
function get_t_fine(self : BME280_record) return int32;
\end{lstlisting}
Returns the \package{t\_fine} value after \function{read\_data()} has been called.  This is primarily for debugging purposes.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the \package{t\_fine} value.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.01\degree{}C.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of 0.01\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : BME280_record) return BBS.units.temp_c;
function get_temp(self : BME280_record) return BBS.units.temp_f;
function get_temp(self : BME280_record) return BBS.units.temp_k;
\end{lstlisting}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is $\frac{1}{256}$Pa.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of $\frac{1}{256}$Pa.
\end{itemize}

\begin{lstlisting}
function get_press(self : BME280_record) return BBS.units.press_p;
function get_press(self : BME280_record) return BBS.units.press_mb;
function get_press(self : BME280_record) return BBS.units.press_atm;
function get_press(self : BME280_record) return BBS.units.press_inHg;
\end{lstlisting}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return integer;
\end{lstlisting}
Returns the calibrated relative humidity as an \datatype{Integer}.  The LSB unit is $\frac{1}{1024}$\% humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity in units of $\frac{1}{1024}$\% humidity.
\end{itemize}

\begin{lstlisting}
function get_hum(self : BME280_record) return float;
\end{lstlisting}
Returns the relative humidity as a percentage relative humidity.
\begin{itemize}
  \item $self$ - The BME280 device to instruct.
  \item Returns the humidity as a percentage relative humidity.
\end{itemize}

\subsection{\package{BBS.embed.i2c.BMP180}}
This is a driver for the Bosch BMP180 temperature and pressure sensor that attaches to an I2C bus \cite{BMP180}.  It has been discontinued by Bosch and is not recommended for new projects.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the BMP180 sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Conversion Kind \\
    \hline
    \constant{cvt\_temp} & Convert Temperature \\
    \constant{cvt\_press0} & Convert pressure with no oversampling \\
    \constant{cvt\_press1} & Convert pressure with oversampling of two \\
    \constant{cvt\_press2} & Convert pressure with oversampling of four  \\
    \constant{cvt\_press3} & Convert pressure with oversampling of eight  \\
  \end{tabular}
  \caption{Constants for BMP180 Conversion Kinds}
  \label{tbl:BMP180Conv}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out BMP180_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure a BMP180 device.  This needs to be called before the device can be used.
\begin{itemize}
  \item $self$ - The BMP180 device to configure.
  \item $port$ - The I2C bus object that the BMP180 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure start_conversion(self : in out BMP180_record;
                           kind : uint8; error : out err_code);
\end{lstlisting}
Instruct the BMP180 to start converting temperature or pressure.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $kind$ - The kind of conversion to start.  See Table \ref{tbl:BMP180Conv} for options.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function data_ready(self : BMP180_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks to see if conversion is complete.  The user software should wait until conversion is complete before attempting to read otherwise the results will be undefined.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the conversion is complete and \constant{False} otherwise.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return float;
\end{lstlisting}
Returns the calibrated temperature value as a \datatype{Float} in \degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature as a \datatype{Float} in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
Returns the calibrated temperature value as an \datatype{Integer}.  The LSB unit is 0.1\degree{}C.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_c;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_f;
function get_temp(self : in out BMP180_record; error : out err_code)
   return BBS.units.temp_k;
\end{lstlisting}
Returns the temperature in units of \degree{}C, \degree{}F, or K, depending on datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.  \item $error$ - The error code from any I2C transactions.

  \item Returns the temperature in units of \degree{}C, \degree{}F, or K.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return integer;
\end{lstlisting}
Returns the calibrated pressure value as an \datatype{Integer}.  The LSB unit is 1Pa.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the temperature in units of 0.1\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_p;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_mb;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_atm;
function get_press(self : BMP180_record; error : out err_code)
   return BBS.units.press_inHg;
\end{lstlisting}
Returns that pressure in units of Pa, mB, Atm, or inHg, depending on the datatype of the destination.
\begin{itemize}
  \item $self$ - The BMP180 device to instruct.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pressure in units of Pa, mB, Atm, or inHg.
\end{itemize}

\subsection{\package{BBS.embed.i2c.L3GD20H}}
This is a driver for the STMicrosystems L3GD20H three-axis digital output gyroscope \cite{L3GD20}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr} is the I2C address of the L3GD20H sensor and is intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fs\_245dps} & Full scale is 245\degree{}/S (default) \\
    \constant{fs\_500dps} & Full scale is 500\degree{}/S \\
    \constant{fs\_2000dps} & Full scale is 2000\degree{}/S \\
  \end{tabular}
  \caption{Constants for L3GD20H Full-Scale Deflection}
  \label{tbl:L3GD20HDef}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{zyx\_or} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{z\_or} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{y\_or} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{x\_or} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{zyxda} & X,Y,Z axis new data available \\
    \constant{zda} & Z axis new data available \\
    \constant{yda} & Y axis new data available \\
    \constant{xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for L3GD20H Status}
  \label{tbl:L3GD20HStat}
\end{center}
\end{table}

Two utility datatypes are defined for holding rotations.  The first,  \datatype{rotations} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw rotation values from the sensor.  The second, \datatype{rotations\_dps} is similar, but the components are all of type \datatype{BBS.units.rot\_d\_s} for rotation in degrees per second.

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out L3GD20H_record; port : i2c_interface;
                    addr : addr7; deflection : uint8; error : out err_code);
\end{lstlisting}
Called to configure the L3GD20H device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The L3GD20H device to configure.
  \item $port$ - The I2C bus object that the L3GD20H is connected to.
  \item $addr$ - The I2C address of the device.
  \item $deflection$ - Set the full-scale deflection (See constants in Table \ref{tbl:L3GD20HDef}).
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : L3GD20H_record; error : out err_code)
    return integer;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return integer;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the rotation around the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations;
\end{lstlisting}
Return a \datatype{rotations} record containing the raw sensor values for the rotations around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : L3GD20H_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_rotation_x(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_y(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
function get_rotation_z(self : L3GD20H_record; error : out err_code)
   return BBS.units.rot_d_s;
\end{lstlisting}
Return the rotation around the specified axis, $x$, $y$, or $z$ as a \datatype{rotations\_dps} containing the rotation in \degree{}/S.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} representing the rotation around the specified axis.
\end{itemize}

\begin{lstlisting}
function get_rotations(self : L3GD20H_record; error : out err_code)
   return rotations_dps;
\end{lstlisting}
Return a \datatype{otations\_dps} record containing the rotation in \degree{}/S around each of the axis.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{rotations\_dps} record containing the rotations around all axis.
\end{itemize}

\begin{lstlisting}
function get_status(self : L3GD20H_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the device status.  The constants in Table \ref{tbl:L3GD20HStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function data_ready(self : L3GD20H_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
 function measure_offsets(self : in out L3GD20H_record) return boolean;
\end{lstlisting}
When stationary, the sensors may not report 0.  This function should be called when the sensor is stationary.  It reads the rotations several times and averages the results.  This is used to calculate offset values.  The offset values are used when returning the rotations in \datatype{rotations\_dps}.

This function returns \constant{True} if the measurement was successful - that is all of the values measured are reasonably close to the mean.  If it returns false, the sensor may be moving.
\begin{itemize}
  \item $self$ - The L3GD20H device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if the offset measurement was successful.
\end{itemize}

\subsection{\package{BBS.embed.i2c.LSM303DLHC}}
This is a driver for the STMicrosystems LSM303DLHC three-axis digital output gyroscope \cite{LSM303DLHC}.  This device has a number of operating modes that have not been implemented in this driver.  A number of constants are defined, but most of them are intended only for internal use.  The constant \constant{addr\_accel} is the I2C address of the LSM303DLHC accelerometer sensor; the constant \constant{addr\_mag} is the I2C address of the magnetometer sensor.  They are intended for use in the \function{configure} call.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fs\_2g} & Full scale is 2G (default) \\
    \constant{fs\_4g} & Full scale is 4G \\
    \constant{fs\_8g} & Full scale is 8G \\
    \constant{fs\_16gs} & Full scale is 16G \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Accelerometer}
  \label{tbl:LSM303DLHCafs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{accel\_stat\_zyxor} & X,Y,Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zor} & Z axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_yor} & Y axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_xorr} & X axis data overrun - New data has overwritten previous data before it was read \\
    \constant{accel\_stat\_zyxda} & X,Y,Z axis new data available \\
    \constant{accel\_stat\_zda} & Z axis new data available \\
    \constant{accel\_stat\_yda} & Y axis new data available \\
    \constant{accel\_stat\_xda} & X axis new data available \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Accelerometer Status}
  \label{tbl:LSM303DLHCaStat}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Full-Scale Deflection \\
    \hline
    \constant{fa\_1\_3\_gauss} & Full scale is 1.3 gauss \\
    \constant{fs\_1\_9\_gauss} & Full scale is 1.9 gauss \\
    \constant{fs\_2\_5\_gauss} & Full scale is 2.5 gauss \\
    \constant{fs\_4\_0\_gauss} & Full scale is 4.0 gauss\\
    \constant{fs\_4\_7\_gauss} & Full scale is 4.7 gauss \\
    \constant{fs\_5\_6\_gauss} & Full scale is 5.6 gauss \\
    \constant{fs\_8\_1\_gauss} & Full scale is 8.1 gauss\\
  \end{tabular}
  \caption{Constants for LSM303DLHC Full-Scale Magnetometer}
  \label{tbl:LSM303DLHCmfs}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Status \\
    \hline
    \constant{mag\_lock} & Data output register lock. \\
    \constant{mag\_drdy} & Data ready \\
  \end{tabular}
  \caption{Constants for LSM303DLHC Magnetometer Status}
  \label{tbl:LSM303DLHCmStat}
\end{center}
\end{table}

Two utility datatypes are defined for holding accelerations.  The first,  \datatype{accelerations} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw acceleration values from the sensor.  The second, \datatype{accelerations\_g} is similar, but the components are all of type \datatype{BBS.units.accel\_g} for acceleration in units on 1 earth gravity.

Two utility datatypes are defined for holding magnetic fields.  The first,  \datatype{magnetism} is a record with \datatype{x}, \datatype{y}, and \datatype{z} components all of \datatype{Integer} type holding the raw magnetometer values from the sensor.  The second, \datatype{magnetism\_gauss} is similar, but the components are all of type \datatype{BBS.units.mag\_g} for magnetism in units on 1 gauss.

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record; port : i2c_interface;
                    accel : addr7; mag : addr7; error : out err_code);
\end{lstlisting}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $accel$ - The I2C address of the device accelerometer.
  \item $mag$ - The I2C address of the device magnetometer.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure configure(self : in out LSM303DLHC_record;
                    port : i2c_interface; addr_accel : addr7; addr_mag : addr7;
                    accel_fs : uint8; mag_fs : uint8; error : out err_code);
\end{lstlisting}
Called to configure the LSM303DLHC device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to configure.
  \item $port$ - The I2C bus object that the LSM303DLHC is connected to.
  \item $addr\_accel$ - The I2C address of the device accelerometer.
  \item $addr\_mag$ - The I2C address of the device magnetometer.
  \item $accel\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCafs}.
  \item $mag\_fs$ - The acceleration full scale value.  See Table \ref{tbl:LSM303DLHCmfs}.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure calibrate_accel(self : in out LSM303DLHC_record);
\end{lstlisting}
The calibrate accel procedure can be called when the sensor is stationary in a 1G acceleration or gravitational field.  It takes multiple measurements of the X, Y, and Z acceleration and computes the average of $X^2 + Y^2 + Z^2$.  This value should be 1.0.  A more sophisticated approach would be to compute a calibration value for each of the axis separately, but that would require the sensor to be precisely positioned three time.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to calibrate.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations;
\end{lstlisting}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_acceleration_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
function get_acceleration_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.accel_g;
\end{lstlisting}
Return the acceleration along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.accel\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.accel\_g} representing the acceleration along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_accelerations(self : LSM303DLHC_record; error : out err_code)
   return accelerations_g;
\end{lstlisting}
Return the acceleration along all axis, $x$, $y$, or $z$ as an \datatype{accelerations\_g} containing the acceleration in units of 1 gravity.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{accelerations\_g} record containing the acceleration along the all axis.
\end{itemize}

\begin{lstlisting}
function get_accel_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the accelerometer status.  The constants in Table \ref{tbl:LSM303DLHCaStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function accel_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the device temperature as an \datatype{Integer} in units of $\frac{1}{8}$\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the temperature in units of $\frac{1}{8}$\degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return float;
\end{lstlisting}
Return the device temperature as a \datatype{Float} in units of 1\degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{Float} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_temperature(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.temp_c;
\end{lstlisting}
Return the device temperature in \degree{}C.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns a \datatype{BBS.units.temp\_c} representing the temperature in \degree{}C.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return integer;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return integer;
\end{lstlisting}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as an \datatype{Integer} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{Integer} representing the magnetic field along the specified axis.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism;
\end{lstlisting}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism} containing the raw sensor value.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_magnet_x(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_y(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
function get_magnet_z(self : LSM303DLHC_record; error : out err_code)
   return BBS.units.mag_g;
\end{lstlisting}
Return the magnetic field along the specified axis, $x$, $y$, or $z$ as a \datatype{BBS.units.mag\_g} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{BBS.units.mag\_g} representing the magnetic field along the specified axis in units of gauss.
\end{itemize}

\begin{lstlisting}
function get_magnetism(self : LSM303DLHC_record; error : out err_code)
   return magnetism_gauss;
\end{lstlisting}
Return the magnetic field along all axis, $x$, $y$, or $z$ as an \datatype{magnetism\_gauss} in units of gauss.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{magnetism\_gauss} record containing the magnetic field along the all axis.
\end{itemize}

\begin{lstlisting}
function get_mag_status(self : LSM303DLHC_record; error : out err_code)
   return uint8;
\end{lstlisting}
Return the magnetometer status.  The constants in Table \ref{tbl:LSM303DLHCmStat} can be used to decode the status.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns an \datatype{uint8} representing the device status.
\end{itemize}

\begin{lstlisting}
function mag_data_ready(self : LSM303DLHC_record; error : out err_code)
   return boolean;
\end{lstlisting}
Checks if the sensor has data ready.
\begin{itemize}
  \item $self$ - The LSM303DLHC device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns \constant{True} if data is ready.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP4725}}
This is a driver for the Microchip MCP4725 digital to analog convertor that attaches to an I2C bus \cite{MCP4725}.

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Command \\
    \hline
    \constant{Fast\_Write} & Fast write. \\
    \constant{Write\_CMD} & Write CMD. \\
    \constant{Write\_EEPROM} & Write EEPROM. \\
  \end{tabular}
  \caption{Constants for MCP4725 Commands}
  \label{tbl:MCP4725cmd}
\end{center}
\end{table}

\begin{table}[!h]
\begin{center}
  \begin{tabular}{l|l}
    Constant & Power-Down Mode \\
    \hline
    \constant{PD\_Normal} & Normal mode. \\
    \constant{PD\_1k} & 1k$\Omega$ to groupd. \\
    \constant{PD\_100k} & 100k$\Omega$ to ground. \\
    \constant{PD\_500k} & 500k$\Omega$ to ground. \\
  \end{tabular}
  \caption{Constants for MCP4725 Power-Down Modes}
  \label{tbl:MCP4725pdm}
\end{center}
\end{table}

\begin{lstlisting}
procedure configure(self : in out MCP4725_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP4725 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP4725 device to configure.
  \item $port$ - The I2C bus object that the MCP4725 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; value : uint12;
              err : out err_code);
\end{lstlisting}
The DAC is only single channel, so this just sets the value using fast write and PD normal mode.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $value$ - The output value to use for the DAC.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set(self : in out MCP4725_record; cmd : CMD_type; mode : Mode_type;
              value : uint12; err : out err_code);
\end{lstlisting}
General set command.  Use the defined constants for the command and mode.  Other values may cause unexpected behavior.
\begin{itemize}
  \item $self$ - The MCP4725 device to set.
  \item $cmd$ - The command to use.  See Table \ref{tbl:MCP4725cmd} for available commands.
  \item $mode$ - The power-down mode to use.  See Table \ref{tbl:MCP4725pdm} for available modes.
  \item $value$ - The output value to use for the command and mode.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23008}}
This is a driver for the Microchip MCP23008 8-bit I/O port extender\cite{MCP23008}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCB23008_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP23008 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $port$ - The I2C bus object that the MCP23008 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCB23008_record; dir : uint8;
                  error : out err_code);
\end{lstlisting}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to configure.
  \item $dir$ - The \datatype{uint8} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCB23008_record; data : uint8;
                   error : out err_code);
\end{lstlisting}
Sets the output bits.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $data$ - The \datatype{uint8} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function read_data(self : MCB23008_record; error : out err_code)
   return uint8;
\end{lstlisting}
Read the port.  Bits are packed into a \datatype{uint8}.
\begin{itemize}
  \item $self$ - The MCP23008 device to set.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint8}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.MCP23017}}
This is a driver for the Microchip MCP23017 8-bit I/O port extender\cite{MCP23017}.  The driver does not support all of the options that the device has.  Should more options be needed, the driver can be extended to support them.  The device can be configured to be at one of eight different I2C addresses.  Constants are defined for each of the possible addresses.  They are \constant{addr\_0} through \constant{addr\_7}.  Refer to your hardware documentation to determine which address you need.

\begin{lstlisting}
procedure configure(self : in out MCP23017_record; port : i2c_interface;
                    addr : addr7; error : out err_code);
\end{lstlisting}
Called to configure the MCP23017 device.  This must be done before using the device.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $port$ - The I2C bus object that the MCP23017 is connected to.
  \item $addr$ - The I2C address of the device.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
procedure set_dir(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Set the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the direction bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_dir(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read the direction (read(0)/write(1)) for each of the output bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the direction bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_polarity(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Set the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the polarity bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_polarity(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read the polarity (normal(0)/inverted(1)) for each of the input bits.  The direction bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the polarity bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_pullup(self : MCP23017_record; dir : uint16;
                  error : out err_code);
\end{lstlisting}
Enable/Disable weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to configure.
  \item $dir$ - The \datatype{uint16} containing the pullup bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_pullup(self : MCP23017_record;
                  error : out err_code) return uint16;
\end{lstlisting}
Read weak pullup resistors (disable(0)/enable(1)) for each of the output bits.  The bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the pullup bits packed into a \datatype{uint16}.
\end{itemize}

\begin{lstlisting}
procedure set_data(self : MCP23017_record; data : uint16;
                   error : out err_code);
\end{lstlisting}
Sets the output bits.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to set.
  \item $data$ - The \datatype{uint16} containing the output bits.
  \item $error$ - The error code from any I2C transactions.
\end{itemize}

\begin{lstlisting}
function get_data(self : MCP23017_record; error : out err_code)
                   return uint16;
\end{lstlisting}
Read the port.  Bits are packed into a \datatype{uint16}.
\begin{itemize}
  \item $self$ - The MCP23017 device to read.
  \item $error$ - The error code from any I2C transactions.
  \item Returns the status if the bits packed into a \datatype{uint16}.
\end{itemize}

\subsection{\package{BBS.embed.i2c.PCA9685}}

\subsection{\package{BBS.embed.SPI.RA8875}}

%========================================================
\chapter{Linux API Description}

%--------------------------------------------------------------------------------------------------
\section{Raspberry Pi}

%--------------------------------------------------------------------------------------------------
\section{BeagleBone Black}

%========================================================
\chapter{Arduino Due API Description}

%========================================================
\chapter{Other Stuff}
\comment{If there is anything else that should be added, additional chapters may be added as needed.}

%========================================================
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{devices.bib}

\end{document}
